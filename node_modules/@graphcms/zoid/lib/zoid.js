!function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define("zoid", [], factory) : "object" == typeof exports ? exports.zoid = factory() : root.zoid = factory();
}("undefined" != typeof self ? self : this, (function() {
    return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                i: moduleId,
                l: !1,
                exports: {}
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.l = !0;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports, name, getter) {
            __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                enumerable: !0,
                get: getter
            });
        };
        __webpack_require__.r = function(exports) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            });
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        };
        __webpack_require__.t = function(value, mode) {
            1 & mode && (value = __webpack_require__(value));
            if (8 & mode) return value;
            if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
            var ns = Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", {
                enumerable: !0,
                value: value
            });
            if (2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
            return ns;
        };
        __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ? function() {
                return module.default;
            } : function() {
                return module;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
        };
        __webpack_require__.o = function(object, property) {
            return {}.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 11);
    }([ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "n", (function() {
            return getParent;
        }));
        __webpack_require__.d(__webpack_exports__, "m", (function() {
            return getOpener;
        }));
        __webpack_require__.d(__webpack_exports__, "h", (function() {
            return getDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "q", (function() {
            return isBlankDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "s", (function() {
            return isSameDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "c", (function() {
            return assertSameDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "e", (function() {
            return getAllFramesInWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "v", (function() {
            return isWindowClosed;
        }));
        __webpack_require__.d(__webpack_exports__, "w", (function() {
            return linkFrameWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "o", (function() {
            return getUserAgent;
        }));
        __webpack_require__.d(__webpack_exports__, "j", (function() {
            return getFrameByName;
        }));
        __webpack_require__.d(__webpack_exports__, "r", (function() {
            return isOpener;
        }));
        __webpack_require__.d(__webpack_exports__, "f", (function() {
            return getAncestor;
        }));
        __webpack_require__.d(__webpack_exports__, "p", (function() {
            return isAncestor;
        }));
        __webpack_require__.d(__webpack_exports__, "g", (function() {
            return getDistanceFromTop;
        }));
        __webpack_require__.d(__webpack_exports__, "l", (function() {
            return getNthParentFromTop;
        }));
        __webpack_require__.d(__webpack_exports__, "t", (function() {
            return isSameTopWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "x", (function() {
            return matchDomain;
        }));
        __webpack_require__.d(__webpack_exports__, "A", (function() {
            return stringifyDomainPattern;
        }));
        __webpack_require__.d(__webpack_exports__, "i", (function() {
            return getDomainFromUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "z", (function() {
            return onCloseWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "u", (function() {
            return isWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "y", (function() {
            return normalizeMockUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "d", (function() {
            return closeWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "k", (function() {
            return getFrameForWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return PROTOCOL;
        }));
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return WINDOW_TYPE;
        }));
        function isRegex(item) {
            return "[object RegExp]" === {}.toString.call(item);
        }
        var PROTOCOL = {
            MOCK: "mock:",
            FILE: "file:",
            ABOUT: "about:"
        };
        var WINDOW_TYPE = {
            IFRAME: "iframe",
            POPUP: "popup"
        };
        var IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
        function isAboutProtocol(win) {
            void 0 === win && (win = window);
            return win.location.protocol === PROTOCOL.ABOUT;
        }
        function getParent(win) {
            void 0 === win && (win = window);
            if (win) try {
                if (win.parent && win.parent !== win) return win.parent;
            } catch (err) {}
        }
        function getOpener(win) {
            void 0 === win && (win = window);
            if (win && !getParent(win)) try {
                return win.opener;
            } catch (err) {}
        }
        function canReadFromWindow(win) {
            try {
                return !0;
            } catch (err) {}
            return !1;
        }
        function getActualDomain(win) {
            void 0 === win && (win = window);
            var location = win.location;
            if (!location) throw new Error("Can not read window location");
            var protocol = location.protocol;
            if (!protocol) throw new Error("Can not read window protocol");
            if (protocol === PROTOCOL.FILE) return PROTOCOL.FILE + "//";
            if (protocol === PROTOCOL.ABOUT) {
                var parent = getParent(win);
                return parent && canReadFromWindow() ? getActualDomain(parent) : PROTOCOL.ABOUT + "//";
            }
            var host = location.host;
            if (!host) throw new Error("Can not read window host");
            return protocol + "//" + host;
        }
        function getDomain(win) {
            void 0 === win && (win = window);
            var domain = getActualDomain(win);
            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(PROTOCOL.MOCK) ? win.mockDomain : domain;
        }
        function isBlankDomain(win) {
            try {
                if (!win.location.href) return !0;
                if ("about:blank" === win.location.href) return !0;
            } catch (err) {}
            return !1;
        }
        function isSameDomain(win) {
            if (!function(win) {
                try {
                    if (win === window) return !0;
                } catch (err) {}
                try {
                    var desc = Object.getOwnPropertyDescriptor(win, "location");
                    if (desc && !1 === desc.enumerable) return !1;
                } catch (err) {}
                try {
                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;
                } catch (err) {}
                try {
                    if (getActualDomain(win) === getActualDomain(window)) return !0;
                } catch (err) {}
                return !1;
            }(win)) return !1;
            try {
                if (win === window) return !0;
                if (isAboutProtocol(win) && canReadFromWindow()) return !0;
                if (getDomain(window) === getDomain(win)) return !0;
            } catch (err) {}
            return !1;
        }
        function assertSameDomain(win) {
            if (!isSameDomain(win)) throw new Error("Expected window to be same domain");
            return win;
        }
        function isAncestorParent(parent, child) {
            if (!parent || !child) return !1;
            var childParent = getParent(child);
            return childParent ? childParent === parent : -1 !== function(win) {
                var result = [];
                try {
                    for (;win.parent !== win; ) {
                        result.push(win.parent);
                        win = win.parent;
                    }
                } catch (err) {}
                return result;
            }(child).indexOf(parent);
        }
        function getFrames(win) {
            var result = [];
            var frames;
            try {
                frames = win.frames;
            } catch (err) {
                frames = win;
            }
            var len;
            try {
                len = frames.length;
            } catch (err) {}
            if (0 === len) return result;
            if (len) {
                for (var i = 0; i < len; i++) {
                    var frame = void 0;
                    try {
                        frame = frames[i];
                    } catch (err) {
                        continue;
                    }
                    result.push(frame);
                }
                return result;
            }
            for (var _i = 0; _i < 100; _i++) {
                var _frame = void 0;
                try {
                    _frame = frames[_i];
                } catch (err) {
                    return result;
                }
                if (!_frame) return result;
                result.push(_frame);
            }
            return result;
        }
        function getAllChildFrames(win) {
            var result = [];
            for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {
                var frame = _getFrames2[_i3];
                result.push(frame);
                for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);
            }
            return result;
        }
        function getTop(win) {
            void 0 === win && (win = window);
            try {
                if (win.top) return win.top;
            } catch (err) {}
            if (getParent(win) === win) return win;
            try {
                if (isAncestorParent(window, win) && window.top) return window.top;
            } catch (err) {}
            try {
                if (isAncestorParent(win, window) && window.top) return window.top;
            } catch (err) {}
            for (var _i7 = 0, _getAllChildFrames4 = getAllChildFrames(win); _i7 < _getAllChildFrames4.length; _i7++) {
                var frame = _getAllChildFrames4[_i7];
                try {
                    if (frame.top) return frame.top;
                } catch (err) {}
                if (getParent(frame) === frame) return frame;
            }
        }
        function getAllFramesInWindow(win) {
            var top = getTop(win);
            if (!top) throw new Error("Can not determine top window");
            var result = [].concat(getAllChildFrames(top), [ top ]);
            -1 === result.indexOf(win) && (result = [].concat(result, [ win ], getAllChildFrames(win)));
            return result;
        }
        var iframeWindows = [];
        var iframeFrames = [];
        function isWindowClosed(win, allowMock) {
            void 0 === allowMock && (allowMock = !0);
            try {
                if (win === window) return !1;
            } catch (err) {
                return !0;
            }
            try {
                if (!win) return !0;
            } catch (err) {
                return !0;
            }
            try {
                if (win.closed) return !0;
            } catch (err) {
                return !err || err.message !== IE_WIN_ACCESS_ERROR;
            }
            if (allowMock && isSameDomain(win)) try {
                if (win.mockclosed) return !0;
            } catch (err) {}
            try {
                if (!win.parent || !win.top) return !0;
            } catch (err) {}
            var iframeIndex = function(collection, item) {
                for (var i = 0; i < collection.length; i++) try {
                    if (collection[i] === item) return i;
                } catch (err) {}
                return -1;
            }(iframeWindows, win);
            if (-1 !== iframeIndex) {
                var frame = iframeFrames[iframeIndex];
                if (frame && function(frame) {
                    if (!frame.contentWindow) return !0;
                    if (!frame.parentNode) return !0;
                    var doc = frame.ownerDocument;
                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {
                        var parent = frame;
                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;
                        if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;
                    }
                    return !1;
                }(frame)) return !0;
            }
            return !1;
        }
        function linkFrameWindow(frame) {
            !function() {
                for (var i = 0; i < iframeWindows.length; i++) {
                    var closed = !1;
                    try {
                        closed = iframeWindows[i].closed;
                    } catch (err) {}
                    if (closed) {
                        iframeFrames.splice(i, 1);
                        iframeWindows.splice(i, 1);
                    }
                }
            }();
            if (frame && frame.contentWindow) try {
                iframeWindows.push(frame.contentWindow);
                iframeFrames.push(frame);
            } catch (err) {}
        }
        function getUserAgent(win) {
            return (win = win || window).navigator.mockUserAgent || win.navigator.userAgent;
        }
        function getFrameByName(win, name) {
            var winFrames = getFrames(win);
            for (var _i9 = 0; _i9 < winFrames.length; _i9++) {
                var childFrame = winFrames[_i9];
                try {
                    if (isSameDomain(childFrame) && childFrame.name === name && -1 !== winFrames.indexOf(childFrame)) return childFrame;
                } catch (err) {}
            }
            try {
                if (-1 !== winFrames.indexOf(win.frames[name])) return win.frames[name];
            } catch (err) {}
            try {
                if (-1 !== winFrames.indexOf(win[name])) return win[name];
            } catch (err) {}
        }
        function isOpener(parent, child) {
            return parent === getOpener(child);
        }
        function getAncestor(win) {
            void 0 === win && (win = window);
            return getOpener(win = win || window) || getParent(win) || void 0;
        }
        function isAncestor(parent, child) {
            var actualParent = getAncestor(child);
            if (actualParent) return actualParent === parent;
            if (child === parent) return !1;
            if (getTop(child) === child) return !1;
            for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;
            return !1;
        }
        function anyMatch(collection1, collection2) {
            for (var _i17 = 0; _i17 < collection1.length; _i17++) {
                var item1 = collection1[_i17];
                for (var _i19 = 0; _i19 < collection2.length; _i19++) if (item1 === collection2[_i19]) return !0;
            }
            return !1;
        }
        function getDistanceFromTop(win) {
            void 0 === win && (win = window);
            var distance = 0;
            var parent = win;
            for (;parent; ) (parent = getParent(parent)) && (distance += 1);
            return distance;
        }
        function getNthParentFromTop(win, n) {
            void 0 === n && (n = 1);
            return function(win, n) {
                void 0 === n && (n = 1);
                var parent = win;
                for (var i = 0; i < n; i++) {
                    if (!parent) return;
                    parent = getParent(parent);
                }
                return parent;
            }(win, getDistanceFromTop(win) - n);
        }
        function isSameTopWindow(win1, win2) {
            var top1 = getTop(win1) || win1;
            var top2 = getTop(win2) || win2;
            try {
                if (top1 && top2) return top1 === top2;
            } catch (err) {}
            var allFrames1 = getAllFramesInWindow(win1);
            var allFrames2 = getAllFramesInWindow(win2);
            if (anyMatch(allFrames1, allFrames2)) return !0;
            var opener1 = getOpener(top1);
            var opener2 = getOpener(top2);
            return opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2) || opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1), 
            !1;
        }
        function matchDomain(pattern, origin) {
            if ("string" == typeof pattern) {
                if ("string" == typeof origin) return "*" === pattern || origin === pattern;
                if (isRegex(origin)) return !1;
                if (Array.isArray(origin)) return !1;
            }
            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {
                return matchDomain(subpattern, origin);
            })));
        }
        function stringifyDomainPattern(pattern) {
            return Array.isArray(pattern) ? "(" + pattern.join(" | ") + ")" : isRegex(pattern) ? "RegExp(" + pattern.toString() : pattern.toString();
        }
        function getDomainFromUrl(url) {
            return url.match(/^(https?|mock|file):\/\//) ? url.split("/").slice(0, 3).join("/") : getDomain();
        }
        function onCloseWindow(win, callback, delay, maxtime) {
            void 0 === delay && (delay = 1e3);
            void 0 === maxtime && (maxtime = 1 / 0);
            var timeout;
            !function check() {
                if (isWindowClosed(win)) {
                    timeout && clearTimeout(timeout);
                    return callback();
                }
                if (maxtime <= 0) clearTimeout(timeout); else {
                    maxtime -= delay;
                    timeout = setTimeout(check, delay);
                }
            }();
            return {
                cancel: function() {
                    timeout && clearTimeout(timeout);
                }
            };
        }
        function isWindow(obj) {
            try {
                if (obj === window) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if ("[object Window]" === {}.toString.call(obj)) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (window.Window && obj instanceof window.Window) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && obj.self === obj) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && obj.parent === obj) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && obj.top === obj) return !0;
            } catch (err) {
                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
            }
            try {
                if (obj && "__unlikely_value__" === obj.__cross_domain_utils_window_check__) return !1;
            } catch (err) {
                return !0;
            }
            try {
                if ("postMessage" in obj && "self" in obj && "location" in obj) return !0;
            } catch (err) {}
            return !1;
        }
        function normalizeMockUrl(url) {
            if (!(domain = getDomainFromUrl(url), 0 === domain.indexOf(PROTOCOL.MOCK))) return url;
            var domain;
            throw new Error("Mock urls not supported out of test mode");
        }
        function closeWindow(win) {
            try {
                win.close();
            } catch (err) {}
        }
        function getFrameForWindow(win) {
            if (isSameDomain(win)) return assertSameDomain(win).frameElement;
            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll("iframe"); _i21 < _document$querySelect2.length; _i21++) {
                var frame = _document$querySelect2[_i21];
                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;
            }
        }
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "getUserAgent", (function() {
            return getUserAgent;
        }));
        __webpack_require__.d(__webpack_exports__, "isDevice", (function() {
            return isDevice;
        }));
        __webpack_require__.d(__webpack_exports__, "isWebView", (function() {
            return isWebView;
        }));
        __webpack_require__.d(__webpack_exports__, "isStandAlone", (function() {
            return isStandAlone;
        }));
        __webpack_require__.d(__webpack_exports__, "isFacebookWebView", (function() {
            return isFacebookWebView;
        }));
        __webpack_require__.d(__webpack_exports__, "isFirefoxIOS", (function() {
            return isFirefoxIOS;
        }));
        __webpack_require__.d(__webpack_exports__, "isEdgeIOS", (function() {
            return isEdgeIOS;
        }));
        __webpack_require__.d(__webpack_exports__, "isOperaMini", (function() {
            return isOperaMini;
        }));
        __webpack_require__.d(__webpack_exports__, "isAndroid", (function() {
            return isAndroid;
        }));
        __webpack_require__.d(__webpack_exports__, "isIos", (function() {
            return isIos;
        }));
        __webpack_require__.d(__webpack_exports__, "isGoogleSearchApp", (function() {
            return isGoogleSearchApp;
        }));
        __webpack_require__.d(__webpack_exports__, "isQQBrowser", (function() {
            return isQQBrowser;
        }));
        __webpack_require__.d(__webpack_exports__, "isIosWebview", (function() {
            return isIosWebview;
        }));
        __webpack_require__.d(__webpack_exports__, "isAndroidWebview", (function() {
            return isAndroidWebview;
        }));
        __webpack_require__.d(__webpack_exports__, "isIE", (function() {
            return device_isIE;
        }));
        __webpack_require__.d(__webpack_exports__, "isIECompHeader", (function() {
            return isIECompHeader;
        }));
        __webpack_require__.d(__webpack_exports__, "isElectron", (function() {
            return isElectron;
        }));
        __webpack_require__.d(__webpack_exports__, "isIEIntranet", (function() {
            return isIEIntranet;
        }));
        __webpack_require__.d(__webpack_exports__, "isMacOsCna", (function() {
            return isMacOsCna;
        }));
        __webpack_require__.d(__webpack_exports__, "supportsPopups", (function() {
            return supportsPopups;
        }));
        __webpack_require__.d(__webpack_exports__, "isChrome", (function() {
            return isChrome;
        }));
        __webpack_require__.d(__webpack_exports__, "isSafari", (function() {
            return isSafari;
        }));
        __webpack_require__.d(__webpack_exports__, "isDocumentReady", (function() {
            return isDocumentReady;
        }));
        __webpack_require__.d(__webpack_exports__, "isDocumentInteractive", (function() {
            return isDocumentInteractive;
        }));
        __webpack_require__.d(__webpack_exports__, "urlEncode", (function() {
            return urlEncode;
        }));
        __webpack_require__.d(__webpack_exports__, "waitForWindowReady", (function() {
            return waitForWindowReady;
        }));
        __webpack_require__.d(__webpack_exports__, "waitForDocumentReady", (function() {
            return waitForDocumentReady;
        }));
        __webpack_require__.d(__webpack_exports__, "waitForDocumentBody", (function() {
            return waitForDocumentBody;
        }));
        __webpack_require__.d(__webpack_exports__, "parseQuery", (function() {
            return parseQuery;
        }));
        __webpack_require__.d(__webpack_exports__, "getQueryParam", (function() {
            return getQueryParam;
        }));
        __webpack_require__.d(__webpack_exports__, "urlWillRedirectPage", (function() {
            return urlWillRedirectPage;
        }));
        __webpack_require__.d(__webpack_exports__, "formatQuery", (function() {
            return formatQuery;
        }));
        __webpack_require__.d(__webpack_exports__, "extendQuery", (function() {
            return extendQuery;
        }));
        __webpack_require__.d(__webpack_exports__, "extendUrl", (function() {
            return extendUrl;
        }));
        __webpack_require__.d(__webpack_exports__, "redirect", (function() {
            return redirect;
        }));
        __webpack_require__.d(__webpack_exports__, "hasMetaViewPort", (function() {
            return hasMetaViewPort;
        }));
        __webpack_require__.d(__webpack_exports__, "isElementVisible", (function() {
            return isElementVisible;
        }));
        __webpack_require__.d(__webpack_exports__, "getPerformance", (function() {
            return getPerformance;
        }));
        __webpack_require__.d(__webpack_exports__, "enablePerformance", (function() {
            return enablePerformance;
        }));
        __webpack_require__.d(__webpack_exports__, "getPageRenderTime", (function() {
            return getPageRenderTime;
        }));
        __webpack_require__.d(__webpack_exports__, "htmlEncode", (function() {
            return htmlEncode;
        }));
        __webpack_require__.d(__webpack_exports__, "isBrowser", (function() {
            return isBrowser;
        }));
        __webpack_require__.d(__webpack_exports__, "querySelectorAll", (function() {
            return querySelectorAll;
        }));
        __webpack_require__.d(__webpack_exports__, "onClick", (function() {
            return onClick;
        }));
        __webpack_require__.d(__webpack_exports__, "getScript", (function() {
            return getScript;
        }));
        __webpack_require__.d(__webpack_exports__, "isLocalStorageEnabled", (function() {
            return isLocalStorageEnabled;
        }));
        __webpack_require__.d(__webpack_exports__, "getBrowserLocales", (function() {
            return getBrowserLocales;
        }));
        __webpack_require__.d(__webpack_exports__, "appendChild", (function() {
            return appendChild;
        }));
        __webpack_require__.d(__webpack_exports__, "isElement", (function() {
            return isElement;
        }));
        __webpack_require__.d(__webpack_exports__, "getElementSafe", (function() {
            return getElementSafe;
        }));
        __webpack_require__.d(__webpack_exports__, "getElement", (function() {
            return getElement;
        }));
        __webpack_require__.d(__webpack_exports__, "elementReady", (function() {
            return elementReady;
        }));
        __webpack_require__.d(__webpack_exports__, "PopupOpenError", (function() {
            return dom_PopupOpenError;
        }));
        __webpack_require__.d(__webpack_exports__, "popup", (function() {
            return popup;
        }));
        __webpack_require__.d(__webpack_exports__, "writeToWindow", (function() {
            return writeToWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "writeElementToWindow", (function() {
            return writeElementToWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "setStyle", (function() {
            return setStyle;
        }));
        __webpack_require__.d(__webpack_exports__, "awaitFrameLoad", (function() {
            return awaitFrameLoad;
        }));
        __webpack_require__.d(__webpack_exports__, "awaitFrameWindow", (function() {
            return awaitFrameWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "createElement", (function() {
            return createElement;
        }));
        __webpack_require__.d(__webpack_exports__, "iframe", (function() {
            return iframe;
        }));
        __webpack_require__.d(__webpack_exports__, "addEventListener", (function() {
            return addEventListener;
        }));
        __webpack_require__.d(__webpack_exports__, "bindEvents", (function() {
            return bindEvents;
        }));
        __webpack_require__.d(__webpack_exports__, "setVendorCSS", (function() {
            return setVendorCSS;
        }));
        __webpack_require__.d(__webpack_exports__, "animate", (function() {
            return animate;
        }));
        __webpack_require__.d(__webpack_exports__, "makeElementVisible", (function() {
            return makeElementVisible;
        }));
        __webpack_require__.d(__webpack_exports__, "makeElementInvisible", (function() {
            return makeElementInvisible;
        }));
        __webpack_require__.d(__webpack_exports__, "showElement", (function() {
            return showElement;
        }));
        __webpack_require__.d(__webpack_exports__, "hideElement", (function() {
            return hideElement;
        }));
        __webpack_require__.d(__webpack_exports__, "destroyElement", (function() {
            return destroyElement;
        }));
        __webpack_require__.d(__webpack_exports__, "showAndAnimate", (function() {
            return showAndAnimate;
        }));
        __webpack_require__.d(__webpack_exports__, "animateAndHide", (function() {
            return animateAndHide;
        }));
        __webpack_require__.d(__webpack_exports__, "addClass", (function() {
            return addClass;
        }));
        __webpack_require__.d(__webpack_exports__, "removeClass", (function() {
            return removeClass;
        }));
        __webpack_require__.d(__webpack_exports__, "isElementClosed", (function() {
            return isElementClosed;
        }));
        __webpack_require__.d(__webpack_exports__, "watchElementForClose", (function() {
            return watchElementForClose;
        }));
        __webpack_require__.d(__webpack_exports__, "fixScripts", (function() {
            return fixScripts;
        }));
        __webpack_require__.d(__webpack_exports__, "onResize", (function() {
            return onResize;
        }));
        __webpack_require__.d(__webpack_exports__, "getResourceLoadTime", (function() {
            return getResourceLoadTime;
        }));
        __webpack_require__.d(__webpack_exports__, "isShadowElement", (function() {
            return isShadowElement;
        }));
        __webpack_require__.d(__webpack_exports__, "getShadowRoot", (function() {
            return getShadowRoot;
        }));
        __webpack_require__.d(__webpack_exports__, "getShadowHost", (function() {
            return getShadowHost;
        }));
        __webpack_require__.d(__webpack_exports__, "insertShadowSlot", (function() {
            return insertShadowSlot;
        }));
        __webpack_require__.d(__webpack_exports__, "preventClickFocus", (function() {
            return preventClickFocus;
        }));
        __webpack_require__.d(__webpack_exports__, "getStackTrace", (function() {
            return getStackTrace;
        }));
        __webpack_require__.d(__webpack_exports__, "getCurrentScript", (function() {
            return getCurrentScript;
        }));
        __webpack_require__.d(__webpack_exports__, "getCurrentScriptUID", (function() {
            return getCurrentScriptUID;
        }));
        __webpack_require__.d(__webpack_exports__, "experiment", (function() {
            return experiment;
        }));
        __webpack_require__.d(__webpack_exports__, "getGlobalNameSpace", (function() {
            return getGlobalNameSpace;
        }));
        __webpack_require__.d(__webpack_exports__, "getStorage", (function() {
            return getStorage;
        }));
        __webpack_require__.d(__webpack_exports__, "getFunctionName", (function() {
            return getFunctionName;
        }));
        __webpack_require__.d(__webpack_exports__, "setFunctionName", (function() {
            return setFunctionName;
        }));
        __webpack_require__.d(__webpack_exports__, "base64encode", (function() {
            return base64encode;
        }));
        __webpack_require__.d(__webpack_exports__, "base64decode", (function() {
            return base64decode;
        }));
        __webpack_require__.d(__webpack_exports__, "uniqueID", (function() {
            return uniqueID;
        }));
        __webpack_require__.d(__webpack_exports__, "getGlobal", (function() {
            return getGlobal;
        }));
        __webpack_require__.d(__webpack_exports__, "getObjectID", (function() {
            return getObjectID;
        }));
        __webpack_require__.d(__webpack_exports__, "getEmptyObject", (function() {
            return getEmptyObject;
        }));
        __webpack_require__.d(__webpack_exports__, "memoize", (function() {
            return memoize;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseIdentity", (function() {
            return promiseIdentity;
        }));
        __webpack_require__.d(__webpack_exports__, "memoizePromise", (function() {
            return memoizePromise;
        }));
        __webpack_require__.d(__webpack_exports__, "promisify", (function() {
            return promisify;
        }));
        __webpack_require__.d(__webpack_exports__, "inlineMemoize", (function() {
            return inlineMemoize;
        }));
        __webpack_require__.d(__webpack_exports__, "noop", (function() {
            return noop;
        }));
        __webpack_require__.d(__webpack_exports__, "once", (function() {
            return once;
        }));
        __webpack_require__.d(__webpack_exports__, "hashStr", (function() {
            return hashStr;
        }));
        __webpack_require__.d(__webpack_exports__, "strHashStr", (function() {
            return strHashStr;
        }));
        __webpack_require__.d(__webpack_exports__, "match", (function() {
            return match;
        }));
        __webpack_require__.d(__webpack_exports__, "awaitKey", (function() {
            return awaitKey;
        }));
        __webpack_require__.d(__webpack_exports__, "stringifyError", (function() {
            return stringifyError;
        }));
        __webpack_require__.d(__webpack_exports__, "stringifyErrorMessage", (function() {
            return stringifyErrorMessage;
        }));
        __webpack_require__.d(__webpack_exports__, "stringify", (function() {
            return stringify;
        }));
        __webpack_require__.d(__webpack_exports__, "domainMatches", (function() {
            return domainMatches;
        }));
        __webpack_require__.d(__webpack_exports__, "patchMethod", (function() {
            return patchMethod;
        }));
        __webpack_require__.d(__webpack_exports__, "extend", (function() {
            return extend;
        }));
        __webpack_require__.d(__webpack_exports__, "values", (function() {
            return values;
        }));
        __webpack_require__.d(__webpack_exports__, "memoizedValues", (function() {
            return memoizedValues;
        }));
        __webpack_require__.d(__webpack_exports__, "perc", (function() {
            return perc;
        }));
        __webpack_require__.d(__webpack_exports__, "min", (function() {
            return min;
        }));
        __webpack_require__.d(__webpack_exports__, "max", (function() {
            return max;
        }));
        __webpack_require__.d(__webpack_exports__, "roundUp", (function() {
            return roundUp;
        }));
        __webpack_require__.d(__webpack_exports__, "regexMap", (function() {
            return regexMap;
        }));
        __webpack_require__.d(__webpack_exports__, "svgToBase64", (function() {
            return svgToBase64;
        }));
        __webpack_require__.d(__webpack_exports__, "objFilter", (function() {
            return objFilter;
        }));
        __webpack_require__.d(__webpack_exports__, "identity", (function() {
            return identity;
        }));
        __webpack_require__.d(__webpack_exports__, "regexTokenize", (function() {
            return regexTokenize;
        }));
        __webpack_require__.d(__webpack_exports__, "promiseDebounce", (function() {
            return promiseDebounce;
        }));
        __webpack_require__.d(__webpack_exports__, "safeInterval", (function() {
            return safeInterval;
        }));
        __webpack_require__.d(__webpack_exports__, "isInteger", (function() {
            return isInteger;
        }));
        __webpack_require__.d(__webpack_exports__, "isFloat", (function() {
            return isFloat;
        }));
        __webpack_require__.d(__webpack_exports__, "serializePrimitive", (function() {
            return serializePrimitive;
        }));
        __webpack_require__.d(__webpack_exports__, "deserializePrimitive", (function() {
            return deserializePrimitive;
        }));
        __webpack_require__.d(__webpack_exports__, "dotify", (function() {
            return dotify;
        }));
        __webpack_require__.d(__webpack_exports__, "undotify", (function() {
            return undotify;
        }));
        __webpack_require__.d(__webpack_exports__, "eventEmitter", (function() {
            return eventEmitter;
        }));
        __webpack_require__.d(__webpack_exports__, "camelToDasherize", (function() {
            return camelToDasherize;
        }));
        __webpack_require__.d(__webpack_exports__, "dasherizeToCamel", (function() {
            return dasherizeToCamel;
        }));
        __webpack_require__.d(__webpack_exports__, "capitalizeFirstLetter", (function() {
            return capitalizeFirstLetter;
        }));
        __webpack_require__.d(__webpack_exports__, "get", (function() {
            return get;
        }));
        __webpack_require__.d(__webpack_exports__, "safeTimeout", (function() {
            return safeTimeout;
        }));
        __webpack_require__.d(__webpack_exports__, "defineLazyProp", (function() {
            return defineLazyProp;
        }));
        __webpack_require__.d(__webpack_exports__, "arrayFrom", (function() {
            return arrayFrom;
        }));
        __webpack_require__.d(__webpack_exports__, "isObject", (function() {
            return isObject;
        }));
        __webpack_require__.d(__webpack_exports__, "isObjectObject", (function() {
            return isObjectObject;
        }));
        __webpack_require__.d(__webpack_exports__, "isPlainObject", (function() {
            return isPlainObject;
        }));
        __webpack_require__.d(__webpack_exports__, "replaceObject", (function() {
            return replaceObject;
        }));
        __webpack_require__.d(__webpack_exports__, "copyProp", (function() {
            return copyProp;
        }));
        __webpack_require__.d(__webpack_exports__, "regex", (function() {
            return regex;
        }));
        __webpack_require__.d(__webpack_exports__, "regexAll", (function() {
            return regexAll;
        }));
        __webpack_require__.d(__webpack_exports__, "isDefined", (function() {
            return isDefined;
        }));
        __webpack_require__.d(__webpack_exports__, "cycle", (function() {
            return cycle;
        }));
        __webpack_require__.d(__webpack_exports__, "debounce", (function() {
            return debounce;
        }));
        __webpack_require__.d(__webpack_exports__, "isRegex", (function() {
            return isRegex;
        }));
        __webpack_require__.d(__webpack_exports__, "weakMapMemoize", (function() {
            return util_weakMapMemoize;
        }));
        __webpack_require__.d(__webpack_exports__, "weakMapMemoizePromise", (function() {
            return util_weakMapMemoizePromise;
        }));
        __webpack_require__.d(__webpack_exports__, "getOrSet", (function() {
            return getOrSet;
        }));
        __webpack_require__.d(__webpack_exports__, "cleanup", (function() {
            return cleanup;
        }));
        __webpack_require__.d(__webpack_exports__, "tryCatch", (function() {
            return tryCatch;
        }));
        __webpack_require__.d(__webpack_exports__, "removeFromArray", (function() {
            return removeFromArray;
        }));
        __webpack_require__.d(__webpack_exports__, "assertExists", (function() {
            return assertExists;
        }));
        __webpack_require__.d(__webpack_exports__, "unique", (function() {
            return unique;
        }));
        __webpack_require__.d(__webpack_exports__, "constHas", (function() {
            return constHas;
        }));
        __webpack_require__.d(__webpack_exports__, "dedupeErrors", (function() {
            return dedupeErrors;
        }));
        __webpack_require__.d(__webpack_exports__, "ExtendableError", (function() {
            return util_ExtendableError;
        }));
        __webpack_require__.d(__webpack_exports__, "request", (function() {
            return request;
        }));
        __webpack_require__.d(__webpack_exports__, "addHeaderBuilder", (function() {
            return addHeaderBuilder;
        }));
        __webpack_require__.d(__webpack_exports__, "TYPES", (function() {
            return TYPES;
        }));
        __webpack_require__.d(__webpack_exports__, "memoized", (function() {
            return memoized;
        }));
        __webpack_require__.d(__webpack_exports__, "promise", (function() {
            return decorators_promise;
        }));
        __webpack_require__.d(__webpack_exports__, "isPerc", (function() {
            return isPerc;
        }));
        __webpack_require__.d(__webpack_exports__, "isPx", (function() {
            return isPx;
        }));
        __webpack_require__.d(__webpack_exports__, "toNum", (function() {
            return toNum;
        }));
        __webpack_require__.d(__webpack_exports__, "toPx", (function() {
            return toPx;
        }));
        __webpack_require__.d(__webpack_exports__, "toCSS", (function() {
            return toCSS;
        }));
        __webpack_require__.d(__webpack_exports__, "percOf", (function() {
            return percOf;
        }));
        __webpack_require__.d(__webpack_exports__, "normalizeDimension", (function() {
            return normalizeDimension;
        }));
        __webpack_require__.d(__webpack_exports__, "wrapPromise", (function() {
            return wrapPromise;
        }));
        __webpack_require__.d(__webpack_exports__, "KEY_CODES", (function() {
            return KEY_CODES;
        }));
        __webpack_require__.d(__webpack_exports__, "ATTRIBUTES", (function() {
            return ATTRIBUTES;
        }));
        function getUserAgent() {
            return window.navigator.mockUserAgent || window.navigator.userAgent;
        }
        function isDevice(userAgent) {
            void 0 === userAgent && (userAgent = getUserAgent());
            return !!userAgent.match(/Android|webOS|iPhone|iPad|iPod|bada|Symbian|Palm|CriOS|BlackBerry|IEMobile|WindowsMobile|Opera Mini/i);
        }
        function isWebView() {
            var userAgent = getUserAgent();
            return /(iPhone|iPod|iPad|Macintosh).*AppleWebKit(?!.*Safari)/i.test(userAgent) || /\bwv\b/.test(userAgent) || /Android.*Version\/(\d)\.(\d)/i.test(userAgent);
        }
        function isStandAlone() {
            return !0 === window.navigator.standalone || window.matchMedia("(display-mode: standalone)").matches;
        }
        function isFacebookWebView(ua) {
            void 0 === ua && (ua = getUserAgent());
            return -1 !== ua.indexOf("FBAN") || -1 !== ua.indexOf("FBAV");
        }
        function isFirefoxIOS(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /FxiOS/i.test(ua);
        }
        function isEdgeIOS(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /EdgiOS/i.test(ua);
        }
        function isOperaMini(ua) {
            void 0 === ua && (ua = getUserAgent());
            return ua.indexOf("Opera Mini") > -1;
        }
        function isAndroid(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Android/.test(ua);
        }
        function isIos(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /iPhone|iPod|iPad/.test(ua);
        }
        function isGoogleSearchApp(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /\bGSA\b/.test(ua);
        }
        function isQQBrowser(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /QQBrowser/.test(ua);
        }
        function isIosWebview(ua) {
            void 0 === ua && (ua = getUserAgent());
            return !!isIos(ua) && (!!isGoogleSearchApp(ua) || /.+AppleWebKit(?!.*Safari)/.test(ua));
        }
        function isAndroidWebview(ua) {
            void 0 === ua && (ua = getUserAgent());
            return !!isAndroid(ua) && /Version\/[\d.]+/.test(ua) && !isOperaMini(ua);
        }
        function device_isIE() {
            return !!window.document.documentMode || Boolean(window.navigator && window.navigator.userAgent && /Edge|MSIE|rv:11/i.test(window.navigator.userAgent));
        }
        function isIECompHeader() {
            var mHttp = window.document.querySelector('meta[http-equiv="X-UA-Compatible"]');
            var mContent = window.document.querySelector('meta[content="IE=edge"]');
            return !(!mHttp || !mContent);
        }
        function isElectron() {
            return !("undefined" == typeof process || !process.versions || !process.versions.electron);
        }
        function isIEIntranet() {
            if (window.document.documentMode) try {
                var status = window.status;
                window.status = "testIntranetMode";
                if ("testIntranetMode" === window.status) {
                    window.status = status;
                    return !0;
                }
                return !1;
            } catch (err) {
                return !1;
            }
            return !1;
        }
        function isMacOsCna() {
            var userAgent = getUserAgent();
            return /Macintosh.*AppleWebKit(?!.*Safari)/i.test(userAgent);
        }
        function supportsPopups(ua) {
            void 0 === ua && (ua = getUserAgent());
            return !(isIosWebview(ua) || isAndroidWebview(ua) || isOperaMini(ua) || isFirefoxIOS(ua) || isEdgeIOS(ua) || isFacebookWebView(ua) || isQQBrowser(ua) || isElectron() || isMacOsCna() || isStandAlone());
        }
        function isChrome(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Chrome|Chromium|CriOS/.test(ua);
        }
        function isSafari(ua) {
            void 0 === ua && (ua = getUserAgent());
            return /Safari/.test(ua) && !isChrome(ua);
        }
        var inheritsLoose = __webpack_require__(8);
        var esm_extends = __webpack_require__(5);
        var src = __webpack_require__(2);
        var cross_domain_utils_src = __webpack_require__(0);
        var cross_domain_safe_weakmap_src = __webpack_require__(7);
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                o.__proto__ = p;
                return o;
            })(o, p);
        }
        function _isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));
                return !0;
            } catch (e) {
                return !1;
            }
        }
        function construct_construct(Parent, args, Class) {
            return (construct_construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a));
                Class && _setPrototypeOf(instance, Class.prototype);
                return instance;
            }).apply(null, arguments);
        }
        function wrapNativeSuper_wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map : void 0;
            return (wrapNativeSuper_wrapNativeSuper = function(Class) {
                if (null === Class || !(fn = Class, -1 !== Function.toString.call(fn).indexOf("[native code]"))) return Class;
                var fn;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return construct_construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                });
                return _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function getFunctionName(fn) {
            return fn.name || fn.__name__ || fn.displayName || "anonymous";
        }
        function setFunctionName(fn, name) {
            try {
                delete fn.name;
                fn.name = name;
            } catch (err) {}
            fn.__name__ = fn.displayName = name;
            return fn;
        }
        function base64encode(str) {
            if ("function" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {
                return String.fromCharCode(parseInt(p1, 16));
            })));
            if ("undefined" != typeof Buffer) return Buffer.from(str, "utf8").toString("base64");
            throw new Error("Can not find window.btoa or Buffer");
        }
        function base64decode(str) {
            if ("function" == typeof atob) return decodeURIComponent([].map.call(atob(str), (function(c) {
                return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
            })).join(""));
            if ("undefined" != typeof Buffer) return Buffer.from(str, "base64").toString("utf8");
            throw new Error("Can not find window.atob or Buffer");
        }
        function uniqueID() {
            var chars = "0123456789abcdef";
            return "xxxxxxxxxx".replace(/./g, (function() {
                return chars.charAt(Math.floor(Math.random() * chars.length));
            })) + "_" + base64encode((new Date).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
        }
        function getGlobal() {
            if ("undefined" != typeof window) return window;
            if ("undefined" != typeof window) return window;
            if ("undefined" != typeof global) return global;
            throw new Error("No global found");
        }
        var objectIDs;
        function getObjectID(obj) {
            objectIDs = objectIDs || new cross_domain_safe_weakmap_src.a;
            if (null == obj || "object" != typeof obj && "function" != typeof obj) throw new Error("Invalid object");
            var uid = objectIDs.get(obj);
            if (!uid) {
                uid = typeof obj + ":" + uniqueID();
                objectIDs.set(obj, uid);
            }
            return uid;
        }
        function serializeArgs(args) {
            try {
                return JSON.stringify([].slice.call(args), (function(subkey, val) {
                    return "function" == typeof val ? "memoize[" + getObjectID(val) + "]" : val;
                }));
            } catch (err) {
                throw new Error("Arguments not serializable -- can not be used to memoize");
            }
        }
        function getEmptyObject() {
            return {};
        }
        var memoizeGlobalIndex = 0;
        var memoizeGlobalIndexValidFrom = 0;
        function memoize(method, options) {
            void 0 === options && (options = {});
            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;
            var simpleCache;
            var thisCache;
            var memoizeIndex = memoizeGlobalIndex;
            memoizeGlobalIndex += 1;
            var memoizedFunction = function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                if (memoizeIndex < memoizeGlobalIndexValidFrom) {
                    simpleCache = null;
                    thisCache = null;
                    memoizeIndex = memoizeGlobalIndex;
                    memoizeGlobalIndex += 1;
                }
                var cache;
                cache = thisNamespace ? (thisCache = thisCache || new cross_domain_safe_weakmap_src.a).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};
                var cacheKey = serializeArgs(args);
                var cacheResult = cache[cacheKey];
                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {
                    delete cache[cacheKey];
                    cacheResult = null;
                }
                if (cacheResult) return cacheResult.value;
                var time = Date.now();
                var value = method.apply(this, arguments);
                cache[cacheKey] = {
                    time: time,
                    value: value
                };
                return value;
            };
            memoizedFunction.reset = function() {
                simpleCache = null;
                thisCache = null;
            };
            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + "::memoized");
        }
        memoize.clear = function() {
            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;
        };
        function promiseIdentity(item) {
            return src.a.resolve(item);
        }
        function memoizePromise(method) {
            var cache = {};
            function memoizedPromiseFunction() {
                var _arguments = arguments, _this = this;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                var key = serializeArgs(args);
                if (cache.hasOwnProperty(key)) return cache[key];
                cache[key] = src.a.try((function() {
                    return method.apply(_this, _arguments);
                })).finally((function() {
                    delete cache[key];
                }));
                return cache[key];
            }
            memoizedPromiseFunction.reset = function() {
                cache = {};
            };
            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + "::promiseMemoized");
        }
        function promisify(method, options) {
            void 0 === options && (options = {});
            function promisifiedFunction() {
                return src.a.try(method, this, arguments);
            }
            options.name && (promisifiedFunction.displayName = options.name + ":promisified");
            return setFunctionName(promisifiedFunction, getFunctionName(method) + "::promisified");
        }
        function inlineMemoize(method, logic, args) {
            void 0 === args && (args = []);
            var cache = method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {};
            var key = serializeArgs(args);
            return cache.hasOwnProperty(key) ? cache[key] : cache[key] = logic.apply(void 0, args);
        }
        function noop() {}
        function once(method) {
            var called = !1;
            return setFunctionName((function() {
                if (!called) {
                    called = !0;
                    return method.apply(this, arguments);
                }
            }), getFunctionName(method) + "::once");
        }
        function hashStr(str) {
            var hash = 0;
            for (var i = 0; i < str.length; i++) hash += str[i].charCodeAt(0) * Math.pow(i % 10 + 1, 5);
            return Math.floor(Math.pow(Math.sqrt(hash), 5));
        }
        function strHashStr(str) {
            var hash = "";
            for (var i = 0; i < str.length; i++) {
                var total = str[i].charCodeAt(0) * i;
                str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));
                hash += String.fromCharCode(97 + Math.abs(total) % 26);
            }
            return hash;
        }
        function match(str, pattern) {
            var regmatch = str.match(pattern);
            if (regmatch) return regmatch[1];
        }
        function awaitKey(obj, key) {
            return new src.a((function(resolve) {
                var value = obj[key];
                if (value) return resolve(value);
                delete obj[key];
                Object.defineProperty(obj, key, {
                    configurable: !0,
                    set: function(item) {
                        (value = item) && resolve(value);
                    },
                    get: function() {
                        return value;
                    }
                });
            }));
        }
        function stringifyError(err, level) {
            void 0 === level && (level = 1);
            if (level >= 3) return "stringifyError stack overflow";
            try {
                if (!err) return "<unknown error: " + {}.toString.call(err) + ">";
                if ("string" == typeof err) return err;
                if (err instanceof Error) {
                    var stack = err && err.stack;
                    var message = err && err.message;
                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
                    if (stack) return stack;
                    if (message) return message;
                }
                return err && err.toString && "function" == typeof err.toString ? err.toString() : {}.toString.call(err);
            } catch (newErr) {
                return "Error while stringifying error: " + stringifyError(newErr, level + 1);
            }
        }
        function stringifyErrorMessage(err) {
            var defaultMessage = "<unknown error: " + {}.toString.call(err) + ">";
            return err ? err instanceof Error ? err.message || defaultMessage : "string" == typeof err.message && err.message || defaultMessage : defaultMessage;
        }
        function stringify(item) {
            return "string" == typeof item ? item : item && item.toString && "function" == typeof item.toString ? item.toString() : {}.toString.call(item);
        }
        function domainMatches(hostname, domain) {
            var index = (hostname = hostname.split("://")[1]).indexOf(domain);
            return -1 !== index && hostname.slice(index) === domain;
        }
        function patchMethod(obj, name, handler) {
            var original = obj[name];
            obj[name] = function() {
                var _arguments2 = arguments, _this2 = this;
                return handler({
                    context: this,
                    args: [].slice.call(arguments),
                    original: original,
                    callOriginal: function() {
                        return original.apply(_this2, _arguments2);
                    }
                });
            };
        }
        function extend(obj, source) {
            if (!source) return obj;
            if (Object.assign) return Object.assign(obj, source);
            for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);
            return obj;
        }
        var values = function(obj) {
            if (Object.values) return Object.values(obj);
            var result = [];
            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);
            return result;
        };
        var memoizedValues = memoize(values);
        function perc(pixels, percentage) {
            return Math.round(pixels * percentage / 100);
        }
        function min() {
            return Math.min.apply(Math, arguments);
        }
        function max() {
            return Math.max.apply(Math, arguments);
        }
        function roundUp(num, nearest) {
            var remainder = num % nearest;
            return remainder ? num - remainder + nearest : num;
        }
        function regexMap(str, regexp, handler) {
            var results = [];
            str.replace(regexp, (function(item) {
                results.push(handler ? handler.apply(null, arguments) : item);
            }));
            return results;
        }
        function svgToBase64(svg) {
            return "data:image/svg+xml;base64," + base64encode(svg);
        }
        function objFilter(obj, filter) {
            void 0 === filter && (filter = Boolean);
            var result = {};
            for (var key in obj) obj.hasOwnProperty(key) && filter(obj[key], key) && (result[key] = obj[key]);
            return result;
        }
        function identity(item) {
            return item;
        }
        function regexTokenize(text, regexp) {
            var result = [];
            text.replace(regexp, (function(token) {
                result.push(token);
                return "";
            }));
            return result;
        }
        function promiseDebounce(method, delay) {
            void 0 === delay && (delay = 50);
            var promise;
            var timeout;
            return setFunctionName((function() {
                timeout && clearTimeout(timeout);
                var localPromise = promise = promise || new src.a;
                timeout = setTimeout((function() {
                    promise = null;
                    timeout = null;
                    src.a.try(method).then((function(result) {
                        localPromise.resolve(result);
                    }), (function(err) {
                        localPromise.reject(err);
                    }));
                }), delay);
                return localPromise;
            }), getFunctionName(method) + "::promiseDebounced");
        }
        function safeInterval(method, time) {
            var timeout;
            !function loop() {
                timeout = setTimeout((function() {
                    method();
                    loop();
                }), time);
            }();
            return {
                cancel: function() {
                    clearTimeout(timeout);
                }
            };
        }
        function isInteger(str) {
            return Boolean(str.match(/^[0-9]+$/));
        }
        function isFloat(str) {
            return Boolean(str.match(/^[0-9]+\.[0-9]+$/));
        }
        function serializePrimitive(value) {
            return value.toString();
        }
        function deserializePrimitive(value) {
            return "true" === value || "false" !== value && (isInteger(value) ? parseInt(value, 10) : isFloat(value) ? parseFloat(value) : value);
        }
        function dotify(obj, prefix, newobj) {
            void 0 === prefix && (prefix = "");
            void 0 === newobj && (newobj = {});
            prefix = prefix ? prefix + "." : prefix;
            for (var key in obj) obj.hasOwnProperty(key) && null != obj[key] && "function" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every((function(val) {
                return "object" != typeof val;
            })) ? newobj["" + prefix + key + "[]"] = obj[key].join(",") : obj[key] && "object" == typeof obj[key] ? newobj = dotify(obj[key], "" + prefix + key, newobj) : newobj["" + prefix + key] = serializePrimitive(obj[key]));
            return newobj;
        }
        function undotify(obj) {
            var result = {};
            for (var key in obj) if (obj.hasOwnProperty(key) && "string" == typeof obj[key]) {
                var value = obj[key];
                if (key.match(/^.+\[\]$/)) {
                    key = key.slice(0, -2);
                    value = value.split(",").map(deserializePrimitive);
                } else value = deserializePrimitive(value);
                var keyResult = result;
                var parts = key.split(".");
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    var isLast = i + 1 === parts.length;
                    var isIndex = !isLast && isInteger(parts[i + 1]);
                    if ("constructor" === part || "prototype" === part || "__proto__" === part) throw new Error("Disallowed key: " + part);
                    isLast ? keyResult[part] = value : keyResult = keyResult[part] = keyResult[part] || (isIndex ? [] : {});
                }
            }
            return result;
        }
        function eventEmitter() {
            var triggered = {};
            var handlers = {};
            return {
                on: function(eventName, handler) {
                    var handlerList = handlers[eventName] = handlers[eventName] || [];
                    handlerList.push(handler);
                    var cancelled = !1;
                    return {
                        cancel: function() {
                            if (!cancelled) {
                                cancelled = !0;
                                handlerList.splice(handlerList.indexOf(handler), 1);
                            }
                        }
                    };
                },
                once: function(eventName, handler) {
                    var listener = this.on(eventName, (function() {
                        listener.cancel();
                        handler();
                    }));
                    return listener;
                },
                trigger: function(eventName) {
                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
                    var handlerList = handlers[eventName];
                    var promises = [];
                    if (handlerList) {
                        var _loop = function(_i2) {
                            var handler = handlerList[_i2];
                            promises.push(src.a.try((function() {
                                return handler.apply(void 0, args);
                            })));
                        };
                        for (var _i2 = 0; _i2 < handlerList.length; _i2++) _loop(_i2);
                    }
                    return src.a.all(promises).then(noop);
                },
                triggerOnce: function(eventName) {
                    if (triggered[eventName]) return src.a.resolve();
                    triggered[eventName] = !0;
                    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];
                    return this.trigger.apply(this, [ eventName ].concat(args));
                },
                reset: function() {
                    handlers = {};
                }
            };
        }
        function camelToDasherize(string) {
            return string.replace(/([A-Z])/g, (function(g) {
                return "-" + g.toLowerCase();
            }));
        }
        function dasherizeToCamel(string) {
            return string.replace(/-([a-z])/g, (function(g) {
                return g[1].toUpperCase();
            }));
        }
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
        }
        function get(item, path, def) {
            if (!path) return def;
            var pathParts = path.split(".");
            for (var i = 0; i < pathParts.length; i++) {
                if ("object" != typeof item || null === item) return def;
                item = item[pathParts[i]];
            }
            return void 0 === item ? def : item;
        }
        function safeTimeout(method, time) {
            var interval = safeInterval((function() {
                if ((time -= 100) <= 0) {
                    interval.cancel();
                    method();
                }
            }), 100);
        }
        function defineLazyProp(obj, key, getter) {
            if (Array.isArray(obj)) {
                if ("number" != typeof key) throw new TypeError("Array key must be number");
            } else if ("object" == typeof obj && null !== obj && "string" != typeof key) throw new TypeError("Object key must be string");
            Object.defineProperty(obj, key, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    delete obj[key];
                    var value = getter();
                    obj[key] = value;
                    return value;
                },
                set: function(value) {
                    delete obj[key];
                    obj[key] = value;
                }
            });
        }
        function arrayFrom(item) {
            return [].slice.call(item);
        }
        function isObject(item) {
            return "object" == typeof item && null !== item;
        }
        function isObjectObject(obj) {
            return isObject(obj) && "[object Object]" === {}.toString.call(obj);
        }
        function isPlainObject(obj) {
            if (!isObjectObject(obj)) return !1;
            var constructor = obj.constructor;
            if ("function" != typeof constructor) return !1;
            var prototype = constructor.prototype;
            return !!isObjectObject(prototype) && !!prototype.hasOwnProperty("isPrototypeOf");
        }
        function replaceObject(item, replacer, fullKey) {
            void 0 === fullKey && (fullKey = "");
            if (Array.isArray(item)) {
                var length = item.length;
                var result = [];
                var _loop2 = function(i) {
                    defineLazyProp(result, i, (function() {
                        var itemKey = fullKey ? fullKey + "." + i : "" + i;
                        var child = replacer(item[i], i, itemKey);
                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                        return child;
                    }));
                };
                for (var i = 0; i < length; i++) _loop2(i);
                return result;
            }
            if (isPlainObject(item)) {
                var _result = {};
                var _loop3 = function(key) {
                    if (!item.hasOwnProperty(key)) return "continue";
                    defineLazyProp(_result, key, (function() {
                        var itemKey = fullKey ? fullKey + "." + key : "" + key;
                        var child = replacer(item[key], key, itemKey);
                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));
                        return child;
                    }));
                };
                for (var key in item) _loop3(key);
                return _result;
            }
            throw new Error("Pass an object or array");
        }
        function copyProp(source, target, name, def) {
            if (source.hasOwnProperty(name)) {
                var descriptor = Object.getOwnPropertyDescriptor(source, name);
                Object.defineProperty(target, name, descriptor);
            } else target[name] = def;
        }
        function regex(pattern, string, start) {
            void 0 === start && (start = 0);
            "string" == typeof pattern && (pattern = new RegExp(pattern));
            var result = string.slice(start).match(pattern);
            if (result) {
                var index = result.index;
                var regmatch = result[0];
                return {
                    text: regmatch,
                    groups: result.slice(1),
                    start: start + index,
                    end: start + index + regmatch.length,
                    length: regmatch.length,
                    replace: function(text) {
                        return regmatch ? "" + regmatch.slice(0, start + index) + text + regmatch.slice(index + regmatch.length) : "";
                    }
                };
            }
        }
        function regexAll(pattern, string) {
            var matches = [];
            var start = 0;
            for (;;) {
                var regmatch = regex(pattern, string, start);
                if (!regmatch) break;
                matches.push(regmatch);
                start = match.end;
            }
            return matches;
        }
        function isDefined(value) {
            return null != value;
        }
        function cycle(method) {
            return src.a.try(method).then((function() {
                return cycle(method);
            }));
        }
        function debounce(method, time) {
            void 0 === time && (time = 100);
            var timeout;
            return setFunctionName((function() {
                var _arguments3 = arguments, _this3 = this;
                clearTimeout(timeout);
                timeout = setTimeout((function() {
                    return method.apply(_this3, _arguments3);
                }), time);
            }), getFunctionName(method) + "::debounced");
        }
        function isRegex(item) {
            return "[object RegExp]" === {}.toString.call(item);
        }
        var util_weakMapMemoize = function(method) {
            var weakmap = new cross_domain_safe_weakmap_src.a;
            return function(arg) {
                var _this4 = this;
                return weakmap.getOrSet(arg, (function() {
                    return method.call(_this4, arg);
                }));
            };
        };
        var util_weakMapMemoizePromise = function(method) {
            var weakmap = new cross_domain_safe_weakmap_src.a;
            return function(arg) {
                var _this5 = this;
                return weakmap.getOrSet(arg, (function() {
                    return method.call(_this5, arg).finally((function() {
                        weakmap.delete(arg);
                    }));
                }));
            };
        };
        function getOrSet(obj, key, getter) {
            if (obj.hasOwnProperty(key)) return obj[key];
            var val = getter();
            obj[key] = val;
            return val;
        }
        function cleanup(obj) {
            var tasks = [];
            var cleaned = !1;
            return {
                set: function(name, item) {
                    if (!cleaned) {
                        obj[name] = item;
                        this.register((function() {
                            delete obj[name];
                        }));
                    }
                    return item;
                },
                register: function(method) {
                    cleaned ? method() : tasks.push(once(method));
                },
                all: function() {
                    var results = [];
                    cleaned = !0;
                    for (;tasks.length; ) {
                        var task = tasks.shift();
                        results.push(task());
                    }
                    return src.a.all(results).then(noop);
                }
            };
        }
        function tryCatch(fn) {
            var result;
            var error;
            try {
                result = fn();
            } catch (err) {
                error = err;
            }
            return {
                result: result,
                error: error
            };
        }
        function removeFromArray(arr, item) {
            var index = arr.indexOf(item);
            -1 !== index && arr.splice(index, 1);
        }
        function assertExists(name, thing) {
            if (null == thing) throw new Error("Expected " + name + " to be present");
            return thing;
        }
        function unique(arr) {
            var result = {};
            for (var _i4 = 0; _i4 < arr.length; _i4++) result[arr[_i4]] = !0;
            return Object.keys(result);
        }
        var constHas = function(constant, value) {
            return -1 !== memoizedValues(constant).indexOf(value);
        };
        function dedupeErrors(handler) {
            var seenErrors = [];
            var seenStringifiedErrors = {};
            return function(err) {
                if (-1 === seenErrors.indexOf(err)) {
                    seenErrors.push(err);
                    var stringifiedError = stringifyError(err);
                    if (!seenStringifiedErrors[stringifiedError]) {
                        seenStringifiedErrors[stringifiedError] = !0;
                        return handler(err);
                    }
                }
            };
        }
        var util_ExtendableError = function(_Error) {
            Object(inheritsLoose.a)(ExtendableError, _Error);
            function ExtendableError(message) {
                var _this6;
                (_this6 = _Error.call(this, message) || this).name = _this6.constructor.name;
                "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(function(self) {
                    if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return self;
                }(_this6), _this6.constructor) : _this6.stack = new Error(message).stack;
                return _this6;
            }
            return ExtendableError;
        }(wrapNativeSuper_wrapNativeSuper(Error));
        var KEY_CODES = {
            ENTER: 13,
            SPACE: 32
        };
        var ATTRIBUTES = {
            UID: "data-uid"
        };
        function isDocumentReady() {
            return Boolean(document.body) && "complete" === document.readyState;
        }
        function isDocumentInteractive() {
            return Boolean(document.body) && "interactive" === document.readyState;
        }
        function urlEncode(str) {
            return str.replace(/\?/g, "%3F").replace(/&/g, "%26").replace(/#/g, "%23").replace(/\+/g, "%2B");
        }
        function waitForWindowReady() {
            return inlineMemoize(waitForWindowReady, (function() {
                return new src.a((function(resolve) {
                    isDocumentReady() && resolve();
                    window.addEventListener("load", (function() {
                        return resolve();
                    }));
                }));
            }));
        }
        var waitForDocumentReady = memoize((function() {
            return new src.a((function(resolve) {
                if (isDocumentReady() || isDocumentInteractive()) return resolve();
                var interval = setInterval((function() {
                    if (isDocumentReady() || isDocumentInteractive()) {
                        clearInterval(interval);
                        return resolve();
                    }
                }), 10);
            }));
        }));
        function waitForDocumentBody() {
            return src.a.try((function() {
                return document.body ? document.body : waitForDocumentReady().then((function() {
                    if (document.body) return document.body;
                    throw new Error("Document ready but document.body not present");
                }));
            }));
        }
        function parseQuery(queryString) {
            return inlineMemoize(parseQuery, (function() {
                var params = {};
                if (!queryString) return params;
                if (-1 === queryString.indexOf("=")) return params;
                for (var _i2 = 0, _queryString$split2 = queryString.split("&"); _i2 < _queryString$split2.length; _i2++) {
                    var pair = _queryString$split2[_i2];
                    (pair = pair.split("="))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));
                }
                return params;
            }), [ queryString ]);
        }
        function getQueryParam(name) {
            return parseQuery(window.location.search.slice(1))[name];
        }
        function urlWillRedirectPage(url) {
            return -1 === url.indexOf("#") || 0 !== url.indexOf("#") && url.split("#")[0] !== window.location.href.split("#")[0];
        }
        function formatQuery(obj) {
            void 0 === obj && (obj = {});
            return Object.keys(obj).filter((function(key) {
                return "string" == typeof obj[key];
            })).map((function(key) {
                return urlEncode(key) + "=" + urlEncode(obj[key]);
            })).join("&");
        }
        function extendQuery(originalQuery, props) {
            void 0 === props && (props = {});
            return props && Object.keys(props).length ? formatQuery(Object(esm_extends.a)({}, parseQuery(originalQuery), props)) : originalQuery;
        }
        function extendUrl(url, options) {
            var query = options.query || {};
            var hash = options.hash || {};
            var originalUrl;
            var originalHash;
            var _url$split = url.split("#");
            originalHash = _url$split[1];
            var _originalUrl$split = (originalUrl = _url$split[0]).split("?");
            originalUrl = _originalUrl$split[0];
            var queryString = extendQuery(_originalUrl$split[1], query);
            var hashString = extendQuery(originalHash, hash);
            queryString && (originalUrl = originalUrl + "?" + queryString);
            hashString && (originalUrl = originalUrl + "#" + hashString);
            return originalUrl;
        }
        function redirect(url, win) {
            void 0 === win && (win = window);
            return new src.a((function(resolve) {
                win.location = url;
                urlWillRedirectPage(url) || resolve();
            }));
        }
        function hasMetaViewPort() {
            var meta = document.querySelector("meta[name=viewport]");
            return !(isDevice() && window.screen.width < 660 && !meta);
        }
        function isElementVisible(el) {
            return Boolean(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
        }
        function getPerformance() {
            return inlineMemoize(getPerformance, (function() {
                var performance = window.performance;
                if (performance && performance.now && performance.timing && performance.timing.connectEnd && performance.timing.navigationStart && Math.abs(performance.now() - Date.now()) > 1e3 && performance.now() - (performance.timing.connectEnd - performance.timing.navigationStart) > 0) return performance;
            }));
        }
        function enablePerformance() {
            return Boolean(getPerformance());
        }
        function getPageRenderTime() {
            return waitForDocumentReady().then((function() {
                var performance = getPerformance();
                if (performance) {
                    var timing = performance.timing;
                    return timing.connectEnd && timing.domInteractive ? timing.domInteractive - timing.connectEnd : void 0;
                }
            }));
        }
        function htmlEncode(html) {
            void 0 === html && (html = "");
            return html.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/\//g, "&#x2F;");
        }
        function isBrowser() {
            return "undefined" != typeof window && void 0 !== window.location;
        }
        function querySelectorAll(selector, doc) {
            void 0 === doc && (doc = window.document);
            return [].slice.call(doc.querySelectorAll(selector));
        }
        function onClick(element, handler) {
            element.addEventListener("touchstart", noop);
            element.addEventListener("click", handler);
            element.addEventListener("keypress", (function(event) {
                if (event.keyCode === KEY_CODES.ENTER || event.keyCode === KEY_CODES.SPACE) return handler(event);
            }));
        }
        function getScript(_ref) {
            var _ref$host = _ref.host, host = void 0 === _ref$host ? window.location.host : _ref$host, path = _ref.path, _ref$reverse = _ref.reverse, reverse = void 0 !== _ref$reverse && _ref$reverse;
            return inlineMemoize(getScript, (function() {
                var url = "" + host + path;
                var scripts = [].slice.call(document.getElementsByTagName("script"));
                reverse && scripts.reverse();
                for (var _i4 = 0; _i4 < scripts.length; _i4++) {
                    var script = scripts[_i4];
                    if (script.src && script.src.replace(/^https?:\/\//, "").split("?")[0] === url) return script;
                }
            }), [ path ]);
        }
        function isLocalStorageEnabled() {
            return inlineMemoize(isLocalStorageEnabled, (function() {
                try {
                    if ("undefined" == typeof window) return !1;
                    if (window.localStorage) {
                        var value = Math.random().toString();
                        window.localStorage.setItem("__test__localStorage__", value);
                        var result = window.localStorage.getItem("__test__localStorage__");
                        window.localStorage.removeItem("__test__localStorage__");
                        if (value === result) return !0;
                    }
                } catch (err) {}
                return !1;
            }));
        }
        function getBrowserLocales() {
            var nav = window.navigator;
            var locales = nav.languages ? [].concat(nav.languages) : [];
            nav.language && locales.push(nav.language);
            nav.userLanguage && locales.push(nav.userLanguage);
            return locales.map((function(locale) {
                if (locale && locale.match(/^[a-z]{2}[-_][A-Z]{2}$/)) {
                    var _locale$split = locale.split(/[-_]/);
                    return {
                        country: _locale$split[1],
                        lang: _locale$split[0]
                    };
                }
                return locale && locale.match(/^[a-z]{2}$/) ? {
                    lang: locale
                } : null;
            })).filter(Boolean);
        }
        function appendChild(container, child) {
            container.appendChild(child);
        }
        function isElement(element) {
            return element instanceof window.Element || null !== element && "object" == typeof element && 1 === element.nodeType && "object" == typeof element.style && "object" == typeof element.ownerDocument;
        }
        function getElementSafe(id, doc) {
            void 0 === doc && (doc = document);
            return isElement(id) ? id : "string" == typeof id ? doc.querySelector(id) : void 0;
        }
        function getElement(id, doc) {
            void 0 === doc && (doc = document);
            var element = getElementSafe(id, doc);
            if (element) return element;
            throw new Error("Can not find element: " + stringify(id));
        }
        function elementReady(id) {
            return new src.a((function(resolve, reject) {
                var name = stringify(id);
                var el = getElementSafe(id);
                if (el) return resolve(el);
                if (isDocumentReady()) return reject(new Error("Document is ready and element " + name + " does not exist"));
                var interval = setInterval((function() {
                    if (el = getElementSafe(id)) {
                        clearInterval(interval);
                        return resolve(el);
                    }
                    if (isDocumentReady()) {
                        clearInterval(interval);
                        return reject(new Error("Document is ready and element " + name + " does not exist"));
                    }
                }), 10);
            }));
        }
        var dom_PopupOpenError = function(_ExtendableError) {
            Object(inheritsLoose.a)(PopupOpenError, _ExtendableError);
            function PopupOpenError() {
                return _ExtendableError.apply(this, arguments) || this;
            }
            return PopupOpenError;
        }(util_ExtendableError);
        function popup(url, options) {
            var width = (options = options || {}).width, height = options.height;
            var top = 0;
            var left = 0;
            width && (window.outerWidth ? left = Math.round((window.outerWidth - width) / 2) + window.screenX : window.screen.width && (left = Math.round((window.screen.width - width) / 2)));
            height && (window.outerHeight ? top = Math.round((window.outerHeight - height) / 2) + window.screenY : window.screen.height && (top = Math.round((window.screen.height - height) / 2)));
            width && height && (options = Object(esm_extends.a)({
                top: top,
                left: left,
                width: width,
                height: height,
                status: 1,
                toolbar: 0,
                menubar: 0,
                resizable: 1,
                scrollbars: 1
            }, options));
            var name = options.name || "";
            delete options.name;
            var params = Object.keys(options).map((function(key) {
                if (null != options[key]) return key + "=" + stringify(options[key]);
            })).filter(Boolean).join(",");
            var win;
            try {
                win = window.open(url, name, params, !0);
            } catch (err) {
                throw new dom_PopupOpenError("Can not open popup window - " + (err.stack || err.message));
            }
            if (Object(cross_domain_utils_src.v)(win)) {
                var err;
                throw new dom_PopupOpenError("Can not open popup window - blocked");
            }
            window.addEventListener("unload", (function() {
                return win.close();
            }));
            return win;
        }
        function writeToWindow(win, html) {
            try {
                win.document.open();
                win.document.write(html);
                win.document.close();
            } catch (err) {
                try {
                    win.location = "javascript: document.open(); document.write(" + JSON.stringify(html) + "); document.close();";
                } catch (err2) {}
            }
        }
        function writeElementToWindow(win, el) {
            var tag = el.tagName.toLowerCase();
            if ("html" !== tag) throw new Error("Expected element to be html, got " + tag);
            var documentElement = win.document.documentElement;
            for (var _i6 = 0, _arrayFrom2 = arrayFrom(documentElement.children); _i6 < _arrayFrom2.length; _i6++) documentElement.removeChild(_arrayFrom2[_i6]);
            for (var _i8 = 0, _arrayFrom4 = arrayFrom(el.children); _i8 < _arrayFrom4.length; _i8++) documentElement.appendChild(_arrayFrom4[_i8]);
        }
        function setStyle(el, styleText, doc) {
            void 0 === doc && (doc = window.document);
            el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));
        }
        var awaitFrameLoadPromises;
        function awaitFrameLoad(frame) {
            if ((awaitFrameLoadPromises = awaitFrameLoadPromises || new cross_domain_safe_weakmap_src.a).has(frame)) {
                var _promise = awaitFrameLoadPromises.get(frame);
                if (_promise) return _promise;
            }
            var promise = new src.a((function(resolve, reject) {
                frame.addEventListener("load", (function() {
                    Object(cross_domain_utils_src.w)(frame);
                    resolve(frame);
                }));
                frame.addEventListener("error", (function(err) {
                    frame.contentWindow ? resolve(frame) : reject(err);
                }));
            }));
            awaitFrameLoadPromises.set(frame, promise);
            return promise;
        }
        function awaitFrameWindow(frame) {
            return awaitFrameLoad(frame).then((function(loadedFrame) {
                if (!loadedFrame.contentWindow) throw new Error("Could not find window in iframe");
                return loadedFrame.contentWindow;
            }));
        }
        function createElement(tag, options, container) {
            void 0 === tag && (tag = "div");
            void 0 === options && (options = {});
            tag = tag.toLowerCase();
            var element = document.createElement(tag);
            options.style && extend(element.style, options.style);
            options.class && (element.className = options.class.join(" "));
            options.id && element.setAttribute("id", options.id);
            if (options.attributes) for (var _i10 = 0, _Object$keys2 = Object.keys(options.attributes); _i10 < _Object$keys2.length; _i10++) {
                var key = _Object$keys2[_i10];
                element.setAttribute(key, options.attributes[key]);
            }
            options.styleSheet && setStyle(element, options.styleSheet);
            container && appendChild(container, element);
            if (options.html) if ("iframe" === tag) {
                if (!container || !element.contentWindow) throw new Error("Iframe html can not be written unless container provided and iframe in DOM");
                writeToWindow(element.contentWindow, options.html);
            } else element.innerHTML = options.html;
            return element;
        }
        function iframe(options, container) {
            void 0 === options && (options = {});
            var attributes = options.attributes || {};
            var style = options.style || {};
            var frame = createElement("iframe", {
                attributes: Object(esm_extends.a)({
                    allowTransparency: "true"
                }, attributes),
                style: Object(esm_extends.a)({
                    backgroundColor: "transparent",
                    border: "none"
                }, style),
                html: options.html,
                class: options.class
            });
            var isIE = window.navigator.userAgent.match(/MSIE|Edge/i);
            frame.hasAttribute("id") || frame.setAttribute("id", uniqueID());
            awaitFrameLoad(frame);
            container && getElement(container).appendChild(frame);
            (options.url || isIE) && frame.setAttribute("src", options.url || "about:blank");
            return frame;
        }
        function addEventListener(obj, event, handler) {
            obj.addEventListener(event, handler);
            return {
                cancel: function() {
                    obj.removeEventListener(event, handler);
                }
            };
        }
        function bindEvents(element, eventNames, handler) {
            handler = once(handler);
            for (var _i12 = 0; _i12 < eventNames.length; _i12++) element.addEventListener(eventNames[_i12], handler);
            return {
                cancel: once((function() {
                    for (var _i14 = 0; _i14 < eventNames.length; _i14++) element.removeEventListener(eventNames[_i14], handler);
                }))
            };
        }
        var VENDOR_PREFIXES = [ "webkit", "moz", "ms", "o" ];
        function setVendorCSS(element, name, value) {
            element.style[name] = value;
            var capitalizedName = capitalizeFirstLetter(name);
            for (var _i16 = 0; _i16 < VENDOR_PREFIXES.length; _i16++) element.style["" + VENDOR_PREFIXES[_i16] + capitalizedName] = value;
        }
        var ANIMATION_START_EVENTS = [ "animationstart", "webkitAnimationStart", "oAnimationStart", "MSAnimationStart" ];
        var ANIMATION_END_EVENTS = [ "animationend", "webkitAnimationEnd", "oAnimationEnd", "MSAnimationEnd" ];
        function animate(element, name, clean, timeout) {
            void 0 === timeout && (timeout = 1e3);
            return new src.a((function(resolve, reject) {
                var el = getElement(element);
                if (!el) return resolve();
                var hasStarted = !1;
                var startTimeout;
                var endTimeout;
                var startEvent;
                var endEvent;
                function cleanUp() {
                    clearTimeout(startTimeout);
                    clearTimeout(endTimeout);
                    startEvent.cancel();
                    endEvent.cancel();
                }
                startEvent = bindEvents(el, ANIMATION_START_EVENTS, (function(event) {
                    if (event.target === el && event.animationName === name) {
                        clearTimeout(startTimeout);
                        event.stopPropagation();
                        startEvent.cancel();
                        hasStarted = !0;
                        endTimeout = setTimeout((function() {
                            cleanUp();
                            resolve();
                        }), timeout);
                    }
                }));
                endEvent = bindEvents(el, ANIMATION_END_EVENTS, (function(event) {
                    if (event.target === el && event.animationName === name) {
                        cleanUp();
                        return "string" == typeof event.animationName && event.animationName !== name ? reject("Expected animation name to be " + name + ", found " + event.animationName) : resolve();
                    }
                }));
                setVendorCSS(el, "animationName", name);
                startTimeout = setTimeout((function() {
                    if (!hasStarted) {
                        cleanUp();
                        return resolve();
                    }
                }), 200);
                clean && clean(cleanUp);
            }));
        }
        function makeElementVisible(element) {
            element.style.setProperty("visibility", "");
        }
        function makeElementInvisible(element) {
            element.style.setProperty("visibility", "hidden", "important");
        }
        function showElement(element) {
            element.style.setProperty("display", "");
        }
        function hideElement(element) {
            element.style.setProperty("display", "none", "important");
        }
        function destroyElement(element) {
            element && element.parentNode && element.parentNode.removeChild(element);
        }
        function showAndAnimate(element, name, clean) {
            var animation = animate(element, name, clean);
            showElement(element);
            return animation;
        }
        function animateAndHide(element, name, clean) {
            return animate(element, name, clean).then((function() {
                hideElement(element);
            }));
        }
        function addClass(element, name) {
            element.classList.add(name);
        }
        function removeClass(element, name) {
            element.classList.remove(name);
        }
        function isElementClosed(el) {
            return !(el && el.parentNode && el.ownerDocument && el.ownerDocument.documentElement && el.ownerDocument.documentElement.contains(el));
        }
        function watchElementForClose(element, handler) {
            handler = once(handler);
            var cancelled = !1;
            var mutationObservers = [];
            var interval;
            var sacrificialFrame;
            var sacrificialFrameWin;
            var cancel = function() {
                cancelled = !0;
                for (var _i18 = 0; _i18 < mutationObservers.length; _i18++) mutationObservers[_i18].disconnect();
                interval && interval.cancel();
                sacrificialFrameWin && sacrificialFrameWin.removeEventListener("unload", elementClosed);
                sacrificialFrame && destroyElement(sacrificialFrame);
            };
            var elementClosed = function() {
                if (!cancelled) {
                    handler();
                    cancel();
                }
            };
            if (isElementClosed(element)) {
                elementClosed();
                return {
                    cancel: cancel
                };
            }
            if (window.MutationObserver) {
                var mutationElement = element.parentElement;
                for (;mutationElement; ) {
                    var mutationObserver = new window.MutationObserver((function() {
                        isElementClosed(element) && elementClosed();
                    }));
                    mutationObserver.observe(mutationElement, {
                        childList: !0
                    });
                    mutationObservers.push(mutationObserver);
                    mutationElement = mutationElement.parentElement;
                }
            }
            (sacrificialFrame = document.createElement("iframe")).setAttribute("name", "__detect_close_" + uniqueID() + "__");
            sacrificialFrame.style.display = "none";
            awaitFrameWindow(sacrificialFrame).then((function(frameWin) {
                (sacrificialFrameWin = Object(cross_domain_utils_src.c)(frameWin)).addEventListener("unload", elementClosed);
            }));
            element.appendChild(sacrificialFrame);
            interval = safeInterval((function() {
                isElementClosed(element) && elementClosed();
            }), 1e3);
            return {
                cancel: cancel
            };
        }
        function fixScripts(el, doc) {
            void 0 === doc && (doc = window.document);
            for (var _i20 = 0, _querySelectorAll2 = querySelectorAll("script", el); _i20 < _querySelectorAll2.length; _i20++) {
                var script = _querySelectorAll2[_i20];
                var parentNode = script.parentNode;
                if (parentNode) {
                    var newScript = doc.createElement("script");
                    newScript.text = script.textContent;
                    parentNode.replaceChild(newScript, script);
                }
            }
        }
        function onResize(el, handler, _temp) {
            var _ref2 = void 0 === _temp ? {} : _temp, _ref2$width = _ref2.width, width = void 0 === _ref2$width || _ref2$width, _ref2$height = _ref2.height, height = void 0 === _ref2$height || _ref2$height, _ref2$interval = _ref2.interval, interval = void 0 === _ref2$interval ? 100 : _ref2$interval, _ref2$win = _ref2.win, win = void 0 === _ref2$win ? window : _ref2$win;
            var currentWidth = el.offsetWidth;
            var currentHeight = el.offsetHeight;
            var canceled = !1;
            handler({
                width: currentWidth,
                height: currentHeight
            });
            var check = function() {
                if (!canceled && isElementVisible(el)) {
                    var newWidth = el.offsetWidth;
                    var newHeight = el.offsetHeight;
                    (width && newWidth !== currentWidth || height && newHeight !== currentHeight) && handler({
                        width: newWidth,
                        height: newHeight
                    });
                    currentWidth = newWidth;
                    currentHeight = newHeight;
                }
            };
            var observer;
            var timeout;
            win.addEventListener("resize", check);
            if (void 0 !== win.ResizeObserver) {
                (observer = new win.ResizeObserver(check)).observe(el);
                timeout = safeInterval(check, 10 * interval);
            } else if (void 0 !== win.MutationObserver) {
                (observer = new win.MutationObserver(check)).observe(el, {
                    attributes: !0,
                    childList: !0,
                    subtree: !0,
                    characterData: !1
                });
                timeout = safeInterval(check, 10 * interval);
            } else timeout = safeInterval(check, interval);
            return {
                cancel: function() {
                    canceled = !0;
                    observer.disconnect();
                    window.removeEventListener("resize", check);
                    timeout.cancel();
                }
            };
        }
        function getResourceLoadTime(url) {
            var performance = getPerformance();
            if (performance && "function" == typeof performance.getEntries) {
                var entries = performance.getEntries();
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    if (entry && entry.name && 0 === entry.name.indexOf(url) && "number" == typeof entry.duration) return Math.floor(entry.duration);
                }
            }
        }
        function isShadowElement(element) {
            for (;element.parentNode; ) element = element.parentNode;
            return "[object ShadowRoot]" === element.toString();
        }
        function getShadowRoot(element) {
            for (;element.parentNode; ) element = element.parentNode;
            if (isShadowElement(element)) return element;
        }
        function getShadowHost(element) {
            var shadowRoot = getShadowRoot(element);
            if (shadowRoot.host) return shadowRoot.host;
        }
        function insertShadowSlot(element) {
            var shadowHost = getShadowHost(element);
            if (!shadowHost) throw new Error("Element is not in shadow dom");
            if (isShadowElement(shadowHost)) throw new Error("Host element is also in shadow dom");
            var slotName = "shadow-slot-" + uniqueID();
            var slot = document.createElement("slot");
            slot.setAttribute("name", slotName);
            element.appendChild(slot);
            var slotProvider = document.createElement("div");
            slotProvider.setAttribute("slot", slotName);
            shadowHost.appendChild(slotProvider);
            return slotProvider;
        }
        function preventClickFocus(el) {
            var onFocus = function onFocus(event) {
                el.removeEventListener("focus", onFocus);
                event.preventDefault();
                el.blur();
                return !1;
            };
            el.addEventListener("mousedown", (function() {
                el.addEventListener("focus", onFocus);
                setTimeout((function() {
                    el.removeEventListener("focus", onFocus);
                }), 1);
            }));
        }
        function getStackTrace() {
            try {
                throw new Error("_");
            } catch (err) {
                return err.stack || "";
            }
        }
        var currentScript = "undefined" != typeof document ? document.currentScript : null;
        var getCurrentScript = memoize((function() {
            if (currentScript) return currentScript;
            if (currentScript = function() {
                try {
                    var stack = getStackTrace();
                    var stackDetails = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(stack);
                    var scriptLocation = stackDetails && stackDetails[1];
                    if (!scriptLocation) return;
                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName("script")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {
                        var script = _Array$prototype$slic2[_i22];
                        if (script.src && script.src === scriptLocation) return script;
                    }
                } catch (err) {}
            }()) return currentScript;
            throw new Error("Can not determine current script");
        }));
        var currentUID = uniqueID();
        var getCurrentScriptUID = memoize((function() {
            var script;
            try {
                script = getCurrentScript();
            } catch (err) {
                return currentUID;
            }
            var uid = script.getAttribute(ATTRIBUTES.UID);
            if (uid && "string" == typeof uid) return uid;
            if ((uid = script.getAttribute(ATTRIBUTES.UID + "-auto")) && "string" == typeof uid) return uid;
            uid = uniqueID();
            script.setAttribute(ATTRIBUTES.UID + "-auto", uid);
            return uid;
        }));
        function getStorage(_ref) {
            var name = _ref.name, _ref$lifetime = _ref.lifetime, lifetime = void 0 === _ref$lifetime ? 12e5 : _ref$lifetime;
            return inlineMemoize(getStorage, (function() {
                var STORAGE_KEY = "__" + name + "_storage__";
                var accessedStorage;
                function getState(handler) {
                    var localStorageEnabled = isLocalStorageEnabled();
                    var storage;
                    accessedStorage && (storage = accessedStorage);
                    if (!storage && localStorageEnabled) {
                        var rawStorage = window.localStorage.getItem(STORAGE_KEY);
                        rawStorage && (storage = JSON.parse(rawStorage));
                    }
                    storage || (storage = getGlobal()[STORAGE_KEY]);
                    storage || (storage = {
                        id: uniqueID()
                    });
                    storage.id || (storage.id = uniqueID());
                    accessedStorage = storage;
                    var result = handler(storage);
                    localStorageEnabled ? window.localStorage.setItem(STORAGE_KEY, JSON.stringify(storage)) : getGlobal()[STORAGE_KEY] = storage;
                    accessedStorage = null;
                    return result;
                }
                function getSession(handler) {
                    return getState((function(storage) {
                        var session = storage.__session__;
                        var now = Date.now();
                        session && now - session.created > lifetime && (session = null);
                        session || (session = {
                            guid: uniqueID(),
                            created: now
                        });
                        storage.__session__ = session;
                        return handler(session);
                    }));
                }
                return {
                    getState: getState,
                    getID: function() {
                        return getState((function(storage) {
                            return storage.id;
                        }));
                    },
                    getSessionState: function(handler) {
                        return getSession((function(session) {
                            session.state = session.state || {};
                            return handler(session.state);
                        }));
                    },
                    getSessionID: function() {
                        return getSession((function(session) {
                            return session.guid;
                        }));
                    }
                };
            }), [ {
                name: name,
                lifetime: lifetime
            } ]);
        }
        function getBelterExperimentStorage() {
            return getStorage({
                name: "belter_experiment"
            });
        }
        function isEventUnique(name) {
            return getBelterExperimentStorage().getSessionState((function(state) {
                state.loggedBeacons = state.loggedBeacons || [];
                if (-1 === state.loggedBeacons.indexOf(name)) {
                    state.loggedBeacons.push(name);
                    return !0;
                }
                return !1;
            }));
        }
        function experiment(_ref) {
            var name = _ref.name, _ref$sample = _ref.sample, sample = void 0 === _ref$sample ? 50 : _ref$sample, _ref$logTreatment = _ref.logTreatment, logTreatment = void 0 === _ref$logTreatment ? noop : _ref$logTreatment, _ref$logCheckpoint = _ref.logCheckpoint, logCheckpoint = void 0 === _ref$logCheckpoint ? noop : _ref$logCheckpoint;
            var throttle = function(name) {
                return getBelterExperimentStorage().getState((function(state) {
                    state.throttlePercentiles = state.throttlePercentiles || {};
                    state.throttlePercentiles[name] = state.throttlePercentiles[name] || Math.floor(100 * Math.random());
                    return state.throttlePercentiles[name];
                }));
            }(name);
            var group;
            var treatment = name + "_" + (group = throttle < sample ? "test" : sample >= 50 || sample <= throttle && throttle < 2 * sample ? "control" : "throttle");
            var started = !1;
            var forced = !1;
            try {
                window.localStorage && window.localStorage.getItem(name) && (forced = !0);
            } catch (err) {}
            return {
                isEnabled: function() {
                    return "test" === group || forced;
                },
                isDisabled: function() {
                    return "test" !== group && !forced;
                },
                getTreatment: function() {
                    return treatment;
                },
                log: function(checkpoint, payload) {
                    void 0 === payload && (payload = {});
                    if (!started) return this;
                    isEventUnique(name + "_" + treatment + "_" + JSON.stringify(payload)) && logTreatment({
                        name: name,
                        treatment: treatment,
                        payload: payload
                    });
                    isEventUnique(name + "_" + treatment + "_" + checkpoint + "_" + JSON.stringify(payload)) && logCheckpoint({
                        name: name,
                        treatment: treatment,
                        checkpoint: checkpoint,
                        payload: payload
                    });
                    return this;
                },
                logStart: function(payload) {
                    void 0 === payload && (payload = {});
                    started = !0;
                    return this.log("start", payload);
                },
                logComplete: function(payload) {
                    void 0 === payload && (payload = {});
                    return this.log("complete", payload);
                }
            };
        }
        function getGlobalNameSpace(_ref) {
            var name = _ref.name, _ref$version = _ref.version, version = void 0 === _ref$version ? "latest" : _ref$version;
            var global = getGlobal();
            var globalKey = "__" + name + "__" + version + "_global__";
            var namespace = global[globalKey] = global[globalKey] || {};
            return {
                get: function(key, defValue) {
                    defValue = defValue || {};
                    return namespace[key] = namespace[key] || defValue;
                }
            };
        }
        var headerBuilders = [];
        function request(_ref) {
            var url = _ref.url, _ref$method = _ref.method, method = void 0 === _ref$method ? "get" : _ref$method, _ref$headers = _ref.headers, headers = void 0 === _ref$headers ? {} : _ref$headers, json = _ref.json, data = _ref.data, body = _ref.body, _ref$win = _ref.win, win = void 0 === _ref$win ? window : _ref$win, _ref$timeout = _ref.timeout, timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
            return new src.a((function(resolve, reject) {
                if (json && data || json && body || data && json) throw new Error("Only options.json or options.data or options.body should be passed");
                var normalizedHeaders = {};
                for (var _i4 = 0, _Object$keys2 = Object.keys(headers); _i4 < _Object$keys2.length; _i4++) {
                    var _key2 = _Object$keys2[_i4];
                    normalizedHeaders[_key2.toLowerCase()] = headers[_key2];
                }
                json ? normalizedHeaders["content-type"] = normalizedHeaders["content-type"] || "application/json" : (data || body) && (normalizedHeaders["content-type"] = normalizedHeaders["content-type"] || "application/x-www-form-urlencoded; charset=utf-8");
                normalizedHeaders.accept = normalizedHeaders.accept || "application/json";
                for (var _i6 = 0; _i6 < headerBuilders.length; _i6++) {
                    var builtHeaders = (0, headerBuilders[_i6])();
                    for (var _i8 = 0, _Object$keys4 = Object.keys(builtHeaders); _i8 < _Object$keys4.length; _i8++) {
                        var _key3 = _Object$keys4[_i8];
                        normalizedHeaders[_key3.toLowerCase()] = builtHeaders[_key3];
                    }
                }
                var xhr = new win.XMLHttpRequest;
                xhr.addEventListener("load", (function() {
                    var responseHeaders = function(rawHeaders) {
                        void 0 === rawHeaders && (rawHeaders = "");
                        var result = {};
                        for (var _i2 = 0, _rawHeaders$trim$spli2 = rawHeaders.trim().split("\n"); _i2 < _rawHeaders$trim$spli2.length; _i2++) {
                            var _line$split = _rawHeaders$trim$spli2[_i2].split(":"), _key = _line$split[0], values = _line$split.slice(1);
                            result[_key.toLowerCase()] = values.join(":").trim();
                        }
                        return result;
                    }(this.getAllResponseHeaders());
                    if (!this.status) return reject(new Error("Request to " + method.toLowerCase() + " " + url + " failed: no response status code."));
                    var contentType = responseHeaders["content-type"];
                    var isJSON = contentType && (0 === contentType.indexOf("application/json") || 0 === contentType.indexOf("text/json"));
                    var responseBody = this.responseText;
                    try {
                        responseBody = JSON.parse(responseBody);
                    } catch (err) {
                        if (isJSON) return reject(new Error("Invalid json: " + this.responseText + "."));
                    }
                    return resolve({
                        status: this.status,
                        headers: responseHeaders,
                        body: responseBody
                    });
                }), !1);
                xhr.addEventListener("error", (function(evt) {
                    reject(new Error("Request to " + method.toLowerCase() + " " + url + " failed: " + evt.toString() + "."));
                }), !1);
                xhr.open(method, url, !0);
                for (var _key4 in normalizedHeaders) normalizedHeaders.hasOwnProperty(_key4) && xhr.setRequestHeader(_key4, normalizedHeaders[_key4]);
                json ? body = JSON.stringify(json) : data && (body = Object.keys(data).map((function(key) {
                    return encodeURIComponent(key) + "=" + (data ? encodeURIComponent(data[key]) : "");
                })).join("&"));
                xhr.timeout = timeout;
                xhr.ontimeout = function() {
                    reject(new Error("Request to " + method.toLowerCase() + " " + url + " has timed out"));
                };
                xhr.send(body);
            }));
        }
        function addHeaderBuilder(method) {
            headerBuilders.push(method);
        }
        var TYPES = !0;
        function memoized(target, name, descriptor) {
            descriptor.value = memoize(descriptor.value, {
                name: name,
                thisNamespace: !0
            });
        }
        function decorators_promise(target, name, descriptor) {
            descriptor.value = promisify(descriptor.value, {
                name: name
            });
        }
        function isPerc(str) {
            return "string" == typeof str && /^[0-9]+%$/.test(str);
        }
        function isPx(str) {
            return "string" == typeof str && /^[0-9]+px$/.test(str);
        }
        function toNum(val) {
            if ("number" == typeof val) return val;
            var match = val.match(/^([0-9]+)(px|%)$/);
            if (!match) throw new Error("Could not match css value from " + val);
            return parseInt(match[1], 10);
        }
        function toPx(val) {
            return toNum(val) + "px";
        }
        function toCSS(val) {
            return "number" == typeof val ? toPx(val) : isPerc(val) ? val : toPx(val);
        }
        function percOf(num, perc) {
            return parseInt(num * toNum(perc) / 100, 10);
        }
        function normalizeDimension(dim, max) {
            if ("number" == typeof dim) return dim;
            if (isPerc(dim)) return percOf(max, dim);
            if (isPx(dim)) return toNum(dim);
            throw new Error("Can not normalize dimension: " + dim);
        }
        function wrapPromise(method, _temp) {
            var _ref$timeout = (void 0 === _temp ? {} : _temp).timeout;
            var expected = [];
            var promises = [];
            var timer = setTimeout((function() {
                expected.length && promises.push(src.a.asyncReject(new Error("Expected " + expected[0] + " to be called")));
            }), void 0 === _ref$timeout ? 5e3 : _ref$timeout);
            var expect = function(name, fn) {
                void 0 === fn && (fn = noop);
                expected.push(name);
                return function() {
                    var _this = this;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    removeFromArray(expected, name);
                    var _tryCatch = tryCatch((function() {
                        var _fn;
                        return (_fn = fn).call.apply(_fn, [ _this ].concat(args));
                    })), result = _tryCatch.result, error = _tryCatch.error;
                    if (error) {
                        promises.push(src.a.asyncReject(error));
                        throw error;
                    }
                    promises.push(src.a.resolve(result));
                    return result;
                };
            };
            var avoid = function(name, fn) {
                void 0 === fn && (fn = noop);
                return function() {
                    var _fn2;
                    promises.push(src.a.asyncReject(new Error("Expected " + name + " to not be called")));
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                    return (_fn2 = fn).call.apply(_fn2, [ this ].concat(args));
                };
            };
            var expectError = function(name, fn) {
                void 0 === fn && (fn = noop);
                expected.push(name);
                return function() {
                    var _this2 = this;
                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                    removeFromArray(expected, name);
                    var _tryCatch2 = tryCatch((function() {
                        var _fn3;
                        return (_fn3 = fn).call.apply(_fn3, [ _this2 ].concat(args));
                    })), result = _tryCatch2.result, error = _tryCatch2.error;
                    if (error) throw error;
                    promises.push(src.a.resolve(result).then((function() {
                        throw new Error("Expected " + name + " to throw an error");
                    }), noop));
                    return result;
                };
            };
            var wait = function wait() {
                return src.a.try((function() {
                    if (promises.length) return promises.pop();
                })).then((function() {
                    return promises.length ? wait() : expected.length ? src.a.delay(10).then(wait) : void 0;
                }));
            };
            promises.push(src.a.try((function() {
                return method({
                    expect: expect,
                    avoid: avoid,
                    expectError: expectError,
                    error: avoid,
                    wait: wait
                });
            })));
            return wait().then((function() {
                clearTimeout(timer);
            }));
        }
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return promise_ZalgoPromise;
        }));
        function utils_isPromise(item) {
            try {
                if (!item) return !1;
                if ("undefined" != typeof Promise && item instanceof Promise) return !0;
                if ("undefined" != typeof window && "function" == typeof window.Window && item instanceof window.Window) return !1;
                if ("undefined" != typeof window && "function" == typeof window.constructor && item instanceof window.constructor) return !1;
                var _toString = {}.toString;
                if (_toString) {
                    var name = _toString.call(item);
                    if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return !1;
                }
                if ("function" == typeof item.then) return !0;
            } catch (err) {
                return !1;
            }
            return !1;
        }
        var dispatchedErrors = [];
        var possiblyUnhandledPromiseHandlers = [];
        var activeCount = 0;
        var flushPromise;
        function flushActive() {
            if (!activeCount && flushPromise) {
                var promise = flushPromise;
                flushPromise = null;
                promise.resolve();
            }
        }
        function startActive() {
            activeCount += 1;
        }
        function endActive() {
            activeCount -= 1;
            flushActive();
        }
        var promise_ZalgoPromise = function() {
            function ZalgoPromise(handler) {
                var _this = this;
                this.resolved = void 0;
                this.rejected = void 0;
                this.errorHandled = void 0;
                this.value = void 0;
                this.error = void 0;
                this.handlers = void 0;
                this.dispatching = void 0;
                this.stack = void 0;
                this.resolved = !1;
                this.rejected = !1;
                this.errorHandled = !1;
                this.handlers = [];
                if (handler) {
                    var _result;
                    var _error;
                    var resolved = !1;
                    var rejected = !1;
                    var isAsync = !1;
                    startActive();
                    try {
                        handler((function(res) {
                            if (isAsync) _this.resolve(res); else {
                                resolved = !0;
                                _result = res;
                            }
                        }), (function(err) {
                            if (isAsync) _this.reject(err); else {
                                rejected = !0;
                                _error = err;
                            }
                        }));
                    } catch (err) {
                        endActive();
                        this.reject(err);
                        return;
                    }
                    endActive();
                    isAsync = !0;
                    resolved ? this.resolve(_result) : rejected && this.reject(_error);
                }
            }
            var _proto = ZalgoPromise.prototype;
            _proto.resolve = function(result) {
                if (this.resolved || this.rejected) return this;
                if (utils_isPromise(result)) throw new Error("Can not resolve promise with another promise");
                this.resolved = !0;
                this.value = result;
                this.dispatch();
                return this;
            };
            _proto.reject = function(error) {
                var _this2 = this;
                if (this.resolved || this.rejected) return this;
                if (utils_isPromise(error)) throw new Error("Can not reject promise with another promise");
                if (!error) {
                    var _err = error && "function" == typeof error.toString ? error.toString() : {}.toString.call(error);
                    error = new Error("Expected reject to be called with Error, got " + _err);
                }
                this.rejected = !0;
                this.error = error;
                this.errorHandled || setTimeout((function() {
                    _this2.errorHandled || function(err, promise) {
                        if (-1 === dispatchedErrors.indexOf(err)) {
                            dispatchedErrors.push(err);
                            setTimeout((function() {
                                throw err;
                            }), 1);
                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);
                        }
                    }(error, _this2);
                }), 1);
                this.dispatch();
                return this;
            };
            _proto.asyncReject = function(error) {
                this.errorHandled = !0;
                this.reject(error);
                return this;
            };
            _proto.dispatch = function() {
                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
                if (!this.dispatching && (resolved || rejected)) {
                    this.dispatching = !0;
                    startActive();
                    var chain = function(firstPromise, secondPromise) {
                        return firstPromise.then((function(res) {
                            secondPromise.resolve(res);
                        }), (function(err) {
                            secondPromise.reject(err);
                        }));
                    };
                    for (var i = 0; i < handlers.length; i++) {
                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;
                        var _result2 = void 0;
                        if (resolved) try {
                            _result2 = onSuccess ? onSuccess(this.value) : this.value;
                        } catch (err) {
                            promise.reject(err);
                            continue;
                        } else if (rejected) {
                            if (!onError) {
                                promise.reject(this.error);
                                continue;
                            }
                            try {
                                _result2 = onError(this.error);
                            } catch (err) {
                                promise.reject(err);
                                continue;
                            }
                        }
                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {
                            _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error);
                            _result2.errorHandled = !0;
                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);
                    }
                    handlers.length = 0;
                    this.dispatching = !1;
                    endActive();
                }
            };
            _proto.then = function(onSuccess, onError) {
                if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
                if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
                var promise = new ZalgoPromise;
                this.handlers.push({
                    promise: promise,
                    onSuccess: onSuccess,
                    onError: onError
                });
                this.errorHandled = !0;
                this.dispatch();
                return promise;
            };
            _proto.catch = function(onError) {
                return this.then(void 0, onError);
            };
            _proto.finally = function(onFinally) {
                if (onFinally && "function" != typeof onFinally && !onFinally.call) throw new Error("Promise.finally expected a function");
                return this.then((function(result) {
                    return ZalgoPromise.try(onFinally).then((function() {
                        return result;
                    }));
                }), (function(err) {
                    return ZalgoPromise.try(onFinally).then((function() {
                        throw err;
                    }));
                }));
            };
            _proto.timeout = function(time, err) {
                var _this3 = this;
                if (this.resolved || this.rejected) return this;
                var timeout = setTimeout((function() {
                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error("Promise timed out after " + time + "ms"));
                }), time);
                return this.then((function(result) {
                    clearTimeout(timeout);
                    return result;
                }));
            };
            _proto.toPromise = function() {
                if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
                return Promise.resolve(this);
            };
            ZalgoPromise.resolve = function(value) {
                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {
                    return value.then(resolve, reject);
                })) : (new ZalgoPromise).resolve(value);
            };
            ZalgoPromise.reject = function(error) {
                return (new ZalgoPromise).reject(error);
            };
            ZalgoPromise.asyncReject = function(error) {
                return (new ZalgoPromise).asyncReject(error);
            };
            ZalgoPromise.all = function(promises) {
                var promise = new ZalgoPromise;
                var count = promises.length;
                var results = [];
                if (!count) {
                    promise.resolve(results);
                    return promise;
                }
                var chain = function(i, firstPromise, secondPromise) {
                    return firstPromise.then((function(res) {
                        results[i] = res;
                        0 == (count -= 1) && promise.resolve(results);
                    }), (function(err) {
                        secondPromise.reject(err);
                    }));
                };
                for (var i = 0; i < promises.length; i++) {
                    var prom = promises[i];
                    if (prom instanceof ZalgoPromise) {
                        if (prom.resolved) {
                            results[i] = prom.value;
                            count -= 1;
                            continue;
                        }
                    } else if (!utils_isPromise(prom)) {
                        results[i] = prom;
                        count -= 1;
                        continue;
                    }
                    chain(i, ZalgoPromise.resolve(prom), promise);
                }
                0 === count && promise.resolve(results);
                return promise;
            };
            ZalgoPromise.hash = function(promises) {
                var result = {};
                var awaitPromises = [];
                var _loop = function(key) {
                    if (promises.hasOwnProperty(key)) {
                        var value = promises[key];
                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {
                            result[key] = res;
                        }))) : result[key] = value;
                    }
                };
                for (var key in promises) _loop(key);
                return ZalgoPromise.all(awaitPromises).then((function() {
                    return result;
                }));
            };
            ZalgoPromise.map = function(items, method) {
                return ZalgoPromise.all(items.map(method));
            };
            ZalgoPromise.onPossiblyUnhandledException = function(handler) {
                return function(handler) {
                    possiblyUnhandledPromiseHandlers.push(handler);
                    return {
                        cancel: function() {
                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);
                        }
                    };
                }(handler);
            };
            ZalgoPromise.try = function(method, context, args) {
                if (method && "function" != typeof method && !method.call) throw new Error("Promise.try expected a function");
                var result;
                startActive();
                try {
                    result = method.apply(context, args || []);
                } catch (err) {
                    endActive();
                    return ZalgoPromise.reject(err);
                }
                endActive();
                return ZalgoPromise.resolve(result);
            };
            ZalgoPromise.delay = function(_delay) {
                return new ZalgoPromise((function(resolve) {
                    setTimeout(resolve, _delay);
                }));
            };
            ZalgoPromise.isPromise = function(value) {
                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);
            };
            ZalgoPromise.flush = function() {
                return function(Zalgo) {
                    var promise = flushPromise = flushPromise || new Zalgo;
                    flushActive();
                    return promise;
                }(ZalgoPromise);
            };
            return ZalgoPromise;
        }();
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "ZOID", (function() {
            return ZOID;
        }));
        __webpack_require__.d(__webpack_exports__, "POST_MESSAGE", (function() {
            return POST_MESSAGE;
        }));
        __webpack_require__.d(__webpack_exports__, "PROP_TYPE", (function() {
            return PROP_TYPE;
        }));
        __webpack_require__.d(__webpack_exports__, "INITIAL_PROPS", (function() {
            return INITIAL_PROPS;
        }));
        __webpack_require__.d(__webpack_exports__, "WINDOW_REFERENCES", (function() {
            return WINDOW_REFERENCES;
        }));
        __webpack_require__.d(__webpack_exports__, "PROP_SERIALIZATION", (function() {
            return PROP_SERIALIZATION;
        }));
        __webpack_require__.d(__webpack_exports__, "CONTEXT", (function() {
            return CONTEXT;
        }));
        __webpack_require__.d(__webpack_exports__, "WILDCARD", (function() {
            return WILDCARD;
        }));
        __webpack_require__.d(__webpack_exports__, "DEFAULT_DIMENSIONS", (function() {
            return DEFAULT_DIMENSIONS;
        }));
        __webpack_require__.d(__webpack_exports__, "EVENT", (function() {
            return EVENT;
        }));
        var cross_domain_utils_src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
        var ZOID = "zoid";
        var POST_MESSAGE = {
            DELEGATE: ZOID + "_delegate",
            ALLOW_DELEGATE: ZOID + "_allow_delegate"
        };
        var PROP_TYPE = {
            STRING: "string",
            OBJECT: "object",
            FUNCTION: "function",
            BOOLEAN: "boolean",
            NUMBER: "number",
            ARRAY: "array"
        };
        var INITIAL_PROPS = {
            RAW: "raw",
            UID: "uid"
        };
        var WINDOW_REFERENCES = {
            OPENER: "opener",
            PARENT: "parent",
            GLOBAL: "global"
        };
        var PROP_SERIALIZATION = {
            JSON: "json",
            DOTIFY: "dotify",
            BASE64: "base64"
        };
        var CONTEXT = cross_domain_utils_src__WEBPACK_IMPORTED_MODULE_0__.b;
        var WILDCARD = "*";
        var DEFAULT_DIMENSIONS = {
            WIDTH: "300px",
            HEIGHT: "150px"
        };
        var EVENT = {
            RENDER: "zoid-render",
            RENDERED: "zoid-rendered",
            DISPLAY: "zoid-display",
            ERROR: "zoid-error",
            CLOSE: "zoid-close",
            DESTROY: "zoid-destroy",
            PROPS: "zoid-props",
            RESIZE: "zoid-resize",
            FOCUS: "zoid-focus"
        };
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return window_ProxyWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "j", (function() {
            return setup;
        }));
        __webpack_require__.d(__webpack_exports__, "e", (function() {
            return destroy;
        }));
        __webpack_require__.d(__webpack_exports__, "i", (function() {
            return setup_serializeMessage;
        }));
        __webpack_require__.d(__webpack_exports__, "d", (function() {
            return setup_deserializeMessage;
        }));
        __webpack_require__.d(__webpack_exports__, "k", (function() {
            return setup_toProxyWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "g", (function() {
            return on_on;
        }));
        __webpack_require__.d(__webpack_exports__, "h", (function() {
            return send_send;
        }));
        __webpack_require__.d(__webpack_exports__, "f", (function() {
            return markWindowKnown;
        }));
        __webpack_require__.d(__webpack_exports__, "c", (function() {
            return cleanUpWindow;
        }));
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return src_bridge;
        }));
        var src = __webpack_require__(0);
        var zalgo_promise_src = __webpack_require__(2);
        var belter_src = __webpack_require__(1);
        var cross_domain_safe_weakmap_src = __webpack_require__(7);
        function getGlobal(win) {
            void 0 === win && (win = window);
            var globalKey = "__post_robot_10_0_42__";
            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};
        }
        var getObj = function() {
            return {};
        };
        function globalStore(key, defStore) {
            void 0 === key && (key = "store");
            void 0 === defStore && (defStore = getObj);
            return Object(belter_src.getOrSet)(getGlobal(), key, (function() {
                var store = defStore();
                return {
                    has: function(storeKey) {
                        return store.hasOwnProperty(storeKey);
                    },
                    get: function(storeKey, defVal) {
                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;
                    },
                    set: function(storeKey, val) {
                        store[storeKey] = val;
                        return val;
                    },
                    del: function(storeKey) {
                        delete store[storeKey];
                    },
                    getOrSet: function(storeKey, getter) {
                        return Object(belter_src.getOrSet)(store, storeKey, getter);
                    },
                    reset: function() {
                        store = defStore();
                    },
                    keys: function() {
                        return Object.keys(store);
                    }
                };
            }));
        }
        var WildCard = function() {};
        function getWildcard() {
            var global = getGlobal();
            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;
            return global.WINDOW_WILDCARD;
        }
        function windowStore(key, defStore) {
            void 0 === key && (key = "store");
            void 0 === defStore && (defStore = getObj);
            return globalStore("windowStore").getOrSet(key, (function() {
                var winStore = new cross_domain_safe_weakmap_src.a;
                var getStore = function(win) {
                    return winStore.getOrSet(win, defStore);
                };
                return {
                    has: function(win) {
                        return getStore(win).hasOwnProperty(key);
                    },
                    get: function(win, defVal) {
                        var store = getStore(win);
                        return store.hasOwnProperty(key) ? store[key] : defVal;
                    },
                    set: function(win, val) {
                        getStore(win)[key] = val;
                        return val;
                    },
                    del: function(win) {
                        delete getStore(win)[key];
                    },
                    getOrSet: function(win, getter) {
                        var store = getStore(win);
                        return Object(belter_src.getOrSet)(store, key, getter);
                    }
                };
            }));
        }
        function getInstanceID() {
            return globalStore("instance").getOrSet("instanceID", belter_src.uniqueID);
        }
        function resolveHelloPromise(win, _ref) {
            var domain = _ref.domain;
            var helloPromises = windowStore("helloPromises");
            var existingPromise = helloPromises.get(win);
            existingPromise && existingPromise.resolve({
                domain: domain
            });
            var newPromise = zalgo_promise_src.a.resolve({
                domain: domain
            });
            helloPromises.set(win, newPromise);
            return newPromise;
        }
        function sayHello(win, _ref4) {
            return (0, _ref4.send)(win, "postrobot_hello", {
                instanceID: getInstanceID()
            }, {
                domain: "*",
                timeout: -1
            }).then((function(_ref5) {
                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;
                resolveHelloPromise(win, {
                    domain: origin
                });
                return {
                    win: win,
                    domain: origin,
                    instanceID: instanceID
                };
            }));
        }
        function getWindowInstanceID(win, _ref6) {
            var send = _ref6.send;
            return windowStore("windowInstanceIDPromises").getOrSet(win, (function() {
                return sayHello(win, {
                    send: send
                }).then((function(_ref7) {
                    return _ref7.instanceID;
                }));
            }));
        }
        function awaitWindowHello(win, timeout, name) {
            void 0 === timeout && (timeout = 5e3);
            void 0 === name && (name = "Window");
            var promise = function(win) {
                return windowStore("helloPromises").getOrSet(win, (function() {
                    return new zalgo_promise_src.a;
                }));
            }(win);
            -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + " did not load after " + timeout + "ms")));
            return promise;
        }
        function markWindowKnown(win) {
            windowStore("knownWindows").set(win, !0);
        }
        function isSerializedType(item) {
            return "object" == typeof item && null !== item && "string" == typeof item.__type__;
        }
        function determineType(val) {
            return void 0 === val ? "undefined" : null === val ? "null" : Array.isArray(val) ? "array" : "function" == typeof val ? "function" : "object" == typeof val ? val instanceof Error ? "error" : "function" == typeof val.then ? "promise" : "[object RegExp]" === {}.toString.call(val) ? "regex" : "[object Date]" === {}.toString.call(val) ? "date" : "object" : "string" == typeof val ? "string" : "number" == typeof val ? "number" : "boolean" == typeof val ? "boolean" : void 0;
        }
        function serializeType(type, val) {
            return {
                __type__: type,
                __val__: val
            };
        }
        var _SERIALIZER;
        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {
            return serializeType("error", {
                message: _ref.message,
                stack: _ref.stack,
                code: _ref.code,
                data: _ref.data
            });
        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {
            return serializeType("regex", val.source);
        }, _SERIALIZER.date = function(val) {
            return serializeType("date", val.toJSON());
        }, _SERIALIZER.array = function(val) {
            return val;
        }, _SERIALIZER.object = function(val) {
            return val;
        }, _SERIALIZER.string = function(val) {
            return val;
        }, _SERIALIZER.number = function(val) {
            return val;
        }, _SERIALIZER.boolean = function(val) {
            return val;
        }, _SERIALIZER.null = function(val) {
            return val;
        }, _SERIALIZER);
        var defaultSerializers = {};
        var _DESERIALIZER;
        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {
            throw new Error("Function serialization is not implemented; nothing to deserialize");
        }, _DESERIALIZER.error = function(_ref2) {
            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;
            var error = new Error(_ref2.message);
            error.code = code;
            data && (error.data = data);
            error.stack = stack + "\n\n" + error.stack;
            return error;
        }, _DESERIALIZER.promise = function() {
            throw new Error("Promise serialization is not implemented; nothing to deserialize");
        }, _DESERIALIZER.regex = function(val) {
            return new RegExp(val);
        }, _DESERIALIZER.date = function(val) {
            return new Date(val);
        }, _DESERIALIZER.array = function(val) {
            return val;
        }, _DESERIALIZER.object = function(val) {
            return val;
        }, _DESERIALIZER.string = function(val) {
            return val;
        }, _DESERIALIZER.number = function(val) {
            return val;
        }, _DESERIALIZER.boolean = function(val) {
            return val;
        }, _DESERIALIZER.null = function(val) {
            return val;
        }, _DESERIALIZER);
        var defaultDeserializers = {};
        function needsBridgeForBrowser() {
            return !!Object(src.o)(window).match(/MSIE|trident|edge\/12|edge\/13/i);
        }
        function needsBridgeForWin(win) {
            return !Object(src.t)(window, win);
        }
        function needsBridgeForDomain(domain, win) {
            if (domain) {
                if (Object(src.h)() !== Object(src.i)(domain)) return !0;
            } else if (win && !Object(src.s)(win)) return !0;
            return !1;
        }
        function needsBridge(_ref) {
            var win = _ref.win, domain = _ref.domain;
            return !(!needsBridgeForBrowser() || domain && !needsBridgeForDomain(domain, win) || win && !needsBridgeForWin(win));
        }
        function getBridgeName(domain) {
            return "__postrobot_bridge___" + (domain = domain || Object(src.i)(domain)).replace(/[^a-zA-Z0-9]+/g, "_");
        }
        function isBridge() {
            return Boolean(window.name && window.name === getBridgeName(Object(src.h)()));
        }
        var documentBodyReady = new zalgo_promise_src.a((function(resolve) {
            if (window.document && window.document.body) return resolve(window.document.body);
            var interval = setInterval((function() {
                if (window.document && window.document.body) {
                    clearInterval(interval);
                    return resolve(window.document.body);
                }
            }), 10);
        }));
        function registerRemoteWindow(win) {
            windowStore("remoteWindowPromises").getOrSet(win, (function() {
                return new zalgo_promise_src.a;
            }));
        }
        function findRemoteWindow(win) {
            var remoteWinPromise = windowStore("remoteWindowPromises").get(win);
            if (!remoteWinPromise) throw new Error("Remote window promise not found");
            return remoteWinPromise;
        }
        function registerRemoteSendMessage(win, domain, sendMessage) {
            findRemoteWindow(win).resolve((function(remoteWin, remoteDomain, message) {
                if (remoteWin !== win) throw new Error("Remote window does not match window");
                if (!Object(src.x)(remoteDomain, domain)) throw new Error("Remote domain " + remoteDomain + " does not match domain " + domain);
                sendMessage.fireAndForget(message);
            }));
        }
        function rejectRemoteSendMessage(win, err) {
            findRemoteWindow(win).reject(err).catch(belter_src.noop);
        }
        function linkWindow(_ref3) {
            var win = _ref3.win, name = _ref3.name, domain = _ref3.domain;
            var popupWindowsByName = globalStore("popupWindowsByName");
            var popupWindowsByWin = windowStore("popupWindowsByWin");
            for (var _i2 = 0, _popupWindowsByName$k2 = popupWindowsByName.keys(); _i2 < _popupWindowsByName$k2.length; _i2++) {
                var winName = _popupWindowsByName$k2[_i2];
                var _details = popupWindowsByName.get(winName);
                _details && !Object(src.v)(_details.win) || popupWindowsByName.del(winName);
            }
            if (Object(src.v)(win)) return {
                win: win,
                name: name,
                domain: domain
            };
            var details = popupWindowsByWin.getOrSet(win, (function() {
                return name ? popupWindowsByName.getOrSet(name, (function() {
                    return {
                        win: win,
                        name: name
                    };
                })) : {
                    win: win
                };
            }));
            if (details.win && details.win !== win) throw new Error("Different window already linked for window: " + (name || "undefined"));
            if (name) {
                details.name = name;
                popupWindowsByName.set(name, details);
            }
            if (domain) {
                details.domain = domain;
                registerRemoteWindow(win);
            }
            popupWindowsByWin.set(win, details);
            return details;
        }
        function setupBridge(_ref) {
            var on = _ref.on, send = _ref.send, receiveMessage = _ref.receiveMessage;
            windowOpen = window.open, window.open = function(url, name, options, last) {
                var win = windowOpen.call(this, Object(src.y)(url), name, options, last);
                if (!win) return win;
                linkWindow({
                    win: win,
                    name: name,
                    domain: url ? Object(src.i)(url) : null
                });
                return win;
            };
            var windowOpen;
            !function(_ref) {
                var on = _ref.on, send = _ref.send, receiveMessage = _ref.receiveMessage;
                var popupWindowsByName = globalStore("popupWindowsByName");
                on("postrobot_open_tunnel", (function(_ref2) {
                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
                    var bridgePromise = globalStore("bridges").get(origin);
                    if (!bridgePromise) throw new Error("Can not find bridge promise for domain " + origin);
                    return bridgePromise.then((function(bridge) {
                        if (source !== bridge) throw new Error("Message source does not matched registered bridge for domain " + origin);
                        if (!data.name) throw new Error("Register window expected to be passed window name");
                        if (!data.sendMessage) throw new Error("Register window expected to be passed sendMessage method");
                        if (!popupWindowsByName.has(data.name)) throw new Error("Window with name " + data.name + " does not exist, or was not opened by this window");
                        var getWindowDetails = function() {
                            return popupWindowsByName.get(data.name);
                        };
                        if (!getWindowDetails().domain) throw new Error("We do not have a registered domain for window " + data.name);
                        if (getWindowDetails().domain !== origin) throw new Error("Message origin " + origin + " does not matched registered window origin " + (getWindowDetails().domain || "unknown"));
                        registerRemoteSendMessage(getWindowDetails().win, origin, data.sendMessage);
                        return {
                            sendMessage: function(message) {
                                if (window && !window.closed && getWindowDetails()) {
                                    var domain = getWindowDetails().domain;
                                    if (domain) try {
                                        receiveMessage({
                                            data: message,
                                            origin: domain,
                                            source: getWindowDetails().win
                                        }, {
                                            on: on,
                                            send: send
                                        });
                                    } catch (err) {
                                        zalgo_promise_src.a.reject(err);
                                    }
                                }
                            }
                        };
                    }));
                }));
            }({
                on: on,
                send: send,
                receiveMessage: receiveMessage
            });
            !function(_ref2) {
                var send = _ref2.send;
                getGlobal(window).openTunnelToParent = function(_ref3) {
                    var name = _ref3.name, source = _ref3.source, canary = _ref3.canary, sendMessage = _ref3.sendMessage;
                    var tunnelWindows = globalStore("tunnelWindows");
                    var parentWindow = Object(src.n)(window);
                    if (!parentWindow) throw new Error("No parent window found to open tunnel to");
                    var id = function(_ref) {
                        var name = _ref.name, source = _ref.source, canary = _ref.canary, sendMessage = _ref.sendMessage;
                        !function() {
                            var tunnelWindows = globalStore("tunnelWindows");
                            for (var _i2 = 0, _tunnelWindows$keys2 = tunnelWindows.keys(); _i2 < _tunnelWindows$keys2.length; _i2++) {
                                var key = _tunnelWindows$keys2[_i2];
                                var tunnelWindow = tunnelWindows[key];
                                try {
                                    Object(belter_src.noop)(tunnelWindow.source);
                                } catch (err) {
                                    tunnelWindows.del(key);
                                    continue;
                                }
                                Object(src.v)(tunnelWindow.source) && tunnelWindows.del(key);
                            }
                        }();
                        var id = Object(belter_src.uniqueID)();
                        globalStore("tunnelWindows").set(id, {
                            name: name,
                            source: source,
                            canary: canary,
                            sendMessage: sendMessage
                        });
                        return id;
                    }({
                        name: name,
                        source: source,
                        canary: canary,
                        sendMessage: sendMessage
                    });
                    return send(parentWindow, "postrobot_open_tunnel", {
                        name: name,
                        sendMessage: function() {
                            var tunnelWindow = tunnelWindows.get(id);
                            try {
                                Object(belter_src.noop)(tunnelWindow && tunnelWindow.source);
                            } catch (err) {
                                tunnelWindows.del(id);
                                return;
                            }
                            if (tunnelWindow && tunnelWindow.source && !Object(src.v)(tunnelWindow.source)) {
                                try {
                                    tunnelWindow.canary();
                                } catch (err) {
                                    return;
                                }
                                tunnelWindow.sendMessage.apply(this, arguments);
                            }
                        }
                    }, {
                        domain: "*"
                    });
                };
            }({
                send: send
            });
            !function(_ref) {
                var on = _ref.on, send = _ref.send, receiveMessage = _ref.receiveMessage;
                zalgo_promise_src.a.try((function() {
                    var opener = Object(src.m)(window);
                    if (opener && needsBridge({
                        win: opener
                    })) {
                        registerRemoteWindow(opener);
                        return (win = opener, windowStore("remoteBridgeAwaiters").getOrSet(win, (function() {
                            return zalgo_promise_src.a.try((function() {
                                var frame = Object(src.j)(win, getBridgeName(Object(src.h)()));
                                if (frame) return Object(src.s)(frame) && getGlobal(Object(src.c)(frame)) ? frame : new zalgo_promise_src.a((function(resolve) {
                                    var interval;
                                    var timeout;
                                    interval = setInterval((function() {
                                        if (frame && Object(src.s)(frame) && getGlobal(Object(src.c)(frame))) {
                                            clearInterval(interval);
                                            clearTimeout(timeout);
                                            return resolve(frame);
                                        }
                                    }), 100);
                                    timeout = setTimeout((function() {
                                        clearInterval(interval);
                                        return resolve();
                                    }), 2e3);
                                }));
                            }));
                        }))).then((function(bridge) {
                            return bridge ? window.name ? getGlobal(Object(src.c)(bridge)).openTunnelToParent({
                                name: window.name,
                                source: window,
                                canary: function() {},
                                sendMessage: function(message) {
                                    try {
                                        Object(belter_src.noop)(window);
                                    } catch (err) {
                                        return;
                                    }
                                    if (window && !window.closed) try {
                                        receiveMessage({
                                            data: message,
                                            origin: this.origin,
                                            source: this.source
                                        }, {
                                            on: on,
                                            send: send
                                        });
                                    } catch (err) {
                                        zalgo_promise_src.a.reject(err);
                                    }
                                }
                            }).then((function(_ref2) {
                                var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
                                if (source !== opener) throw new Error("Source does not match opener");
                                registerRemoteSendMessage(source, origin, data.sendMessage);
                            })).catch((function(err) {
                                rejectRemoteSendMessage(opener, err);
                                throw err;
                            })) : rejectRemoteSendMessage(opener, new Error("Can not register with opener: window does not have a name")) : rejectRemoteSendMessage(opener, new Error("Can not register with opener: no bridge found in opener"));
                        }));
                        var win;
                    }
                }));
            }({
                on: on,
                send: send,
                receiveMessage: receiveMessage
            });
        }
        function cleanupProxyWindows() {
            var idToProxyWindow = globalStore("idToProxyWindow");
            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {
                var id = _idToProxyWindow$keys2[_i2];
                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);
            }
        }
        function getSerializedWindow(winPromise, _ref) {
            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? Object(belter_src.uniqueID)() : _ref$id;
            var windowNamePromise = winPromise.then((function(win) {
                if (Object(src.s)(win)) return Object(src.c)(win).name;
            }));
            var windowTypePromise = winPromise.then((function(window) {
                if (Object(src.v)(window)) throw new Error("Window is closed, can not determine type");
                return Object(src.m)(window) ? src.b.POPUP : src.b.IFRAME;
            }));
            windowNamePromise.catch(belter_src.noop);
            windowTypePromise.catch(belter_src.noop);
            return {
                id: id,
                getType: function() {
                    return windowTypePromise;
                },
                getInstanceID: Object(belter_src.memoizePromise)((function() {
                    return winPromise.then((function(win) {
                        return getWindowInstanceID(win, {
                            send: send
                        });
                    }));
                })),
                close: function() {
                    return winPromise.then(src.d);
                },
                getName: function() {
                    return winPromise.then((function(win) {
                        if (!Object(src.v)(win)) return Object(src.s)(win) ? Object(src.c)(win).name : windowNamePromise;
                    }));
                },
                focus: function() {
                    return winPromise.then((function(win) {
                        win.focus();
                    }));
                },
                isClosed: function() {
                    return winPromise.then((function(win) {
                        return Object(src.v)(win);
                    }));
                },
                setLocation: function(href) {
                    return winPromise.then((function(win) {
                        var domain = window.location.protocol + "//" + window.location.host;
                        if (0 === href.indexOf("/")) href = "" + domain + href; else if (!href.match(/^https?:\/\//) && 0 !== href.indexOf(domain)) throw new Error("Expected url to be http or https url, or absolute path, got " + JSON.stringify(href));
                        if (Object(src.s)(win)) try {
                            if (win.location && "function" == typeof win.location.replace) {
                                win.location.replace(href);
                                return;
                            }
                        } catch (err) {}
                        win.location = href;
                    }));
                },
                setName: function(name) {
                    return winPromise.then((function(win) {
                        linkWindow({
                            win: win,
                            name: name
                        });
                        var sameDomain = Object(src.s)(win);
                        var frame = Object(src.k)(win);
                        if (!sameDomain) throw new Error("Can not set name for cross-domain window: " + name);
                        Object(src.c)(win).name = name;
                        frame && frame.setAttribute("name", name);
                        windowNamePromise = zalgo_promise_src.a.resolve(name);
                    }));
                }
            };
        }
        var window_ProxyWindow = function() {
            function ProxyWindow(_ref2) {
                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;
                this.id = void 0;
                this.isProxyWindow = !0;
                this.serializedWindow = void 0;
                this.actualWindow = void 0;
                this.actualWindowPromise = void 0;
                this.send = void 0;
                this.name = void 0;
                this.actualWindowPromise = new zalgo_promise_src.a;
                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {
                    send: send
                });
                globalStore("idToProxyWindow").set(this.getID(), this);
                win && this.setWindow(win, {
                    send: send
                });
            }
            var _proto = ProxyWindow.prototype;
            _proto.getID = function() {
                return this.serializedWindow.id;
            };
            _proto.getType = function() {
                return this.serializedWindow.getType();
            };
            _proto.isPopup = function() {
                return this.getType().then((function(type) {
                    return type === src.b.POPUP;
                }));
            };
            _proto.setLocation = function(href) {
                var _this = this;
                return this.serializedWindow.setLocation(href).then((function() {
                    return _this;
                }));
            };
            _proto.getName = function() {
                return this.serializedWindow.getName();
            };
            _proto.setName = function(name) {
                var _this2 = this;
                return this.serializedWindow.setName(name).then((function() {
                    return _this2;
                }));
            };
            _proto.close = function() {
                var _this3 = this;
                return this.serializedWindow.close().then((function() {
                    return _this3;
                }));
            };
            _proto.focus = function() {
                var _this4 = this;
                var isPopupPromise = this.isPopup();
                var getNamePromise = this.getName();
                var reopenPromise = zalgo_promise_src.a.hash({
                    isPopup: isPopupPromise,
                    name: getNamePromise
                }).then((function(_ref3) {
                    var name = _ref3.name;
                    _ref3.isPopup && name && window.open("", name);
                }));
                var focusPromise = this.serializedWindow.focus();
                return zalgo_promise_src.a.all([ reopenPromise, focusPromise ]).then((function() {
                    return _this4;
                }));
            };
            _proto.isClosed = function() {
                return this.serializedWindow.isClosed();
            };
            _proto.getWindow = function() {
                return this.actualWindow;
            };
            _proto.setWindow = function(win, _ref4) {
                var send = _ref4.send;
                this.actualWindow = win;
                this.actualWindowPromise.resolve(this.actualWindow);
                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {
                    send: send,
                    id: this.getID()
                });
                windowStore("winToProxyWindow").set(win, this);
            };
            _proto.awaitWindow = function() {
                return this.actualWindowPromise;
            };
            _proto.matchWindow = function(win, _ref5) {
                var _this5 = this;
                var send = _ref5.send;
                return zalgo_promise_src.a.try((function() {
                    return _this5.actualWindow ? win === _this5.actualWindow : zalgo_promise_src.a.hash({
                        proxyInstanceID: _this5.getInstanceID(),
                        knownWindowInstanceID: getWindowInstanceID(win, {
                            send: send
                        })
                    }).then((function(_ref6) {
                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;
                        match && _this5.setWindow(win, {
                            send: send
                        });
                        return match;
                    }));
                }));
            };
            _proto.unwrap = function() {
                return this.actualWindow || this;
            };
            _proto.getInstanceID = function() {
                return this.serializedWindow.getInstanceID();
            };
            _proto.shouldClean = function() {
                return Boolean(this.actualWindow && Object(src.v)(this.actualWindow));
            };
            _proto.serialize = function() {
                return this.serializedWindow;
            };
            ProxyWindow.unwrap = function(win) {
                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;
            };
            ProxyWindow.serialize = function(win, _ref7) {
                var send = _ref7.send;
                cleanupProxyWindows();
                return ProxyWindow.toProxyWindow(win, {
                    send: send
                }).serialize();
            };
            ProxyWindow.deserialize = function(serializedWindow, _ref8) {
                var send = _ref8.send;
                cleanupProxyWindows();
                return globalStore("idToProxyWindow").get(serializedWindow.id) || new ProxyWindow({
                    serializedWindow: serializedWindow,
                    send: send
                });
            };
            ProxyWindow.isProxyWindow = function(obj) {
                return Boolean(obj && !Object(src.u)(obj) && obj.isProxyWindow);
            };
            ProxyWindow.toProxyWindow = function(win, _ref9) {
                var send = _ref9.send;
                cleanupProxyWindows();
                if (ProxyWindow.isProxyWindow(win)) return win;
                var actualWindow = win;
                return windowStore("winToProxyWindow").get(actualWindow) || new ProxyWindow({
                    win: actualWindow,
                    send: send
                });
            };
            return ProxyWindow;
        }();
        function addMethod(id, val, name, source, domain) {
            var methodStore = windowStore("methodStore");
            var proxyWindowMethods = globalStore("proxyWindowMethods");
            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {
                val: val,
                name: name,
                domain: domain,
                source: source
            }); else {
                proxyWindowMethods.del(id);
                methodStore.getOrSet(source, (function() {
                    return {};
                }))[id] = {
                    domain: domain,
                    name: name,
                    val: val,
                    source: source
                };
            }
        }
        function lookupMethod(source, id) {
            var methodStore = windowStore("methodStore");
            var proxyWindowMethods = globalStore("proxyWindowMethods");
            return methodStore.getOrSet(source, (function() {
                return {};
            }))[id] || proxyWindowMethods.get(id);
        }
        function function_serializeFunction(destination, domain, val, key, _ref3) {
            on = (_ref = {
                on: _ref3.on,
                send: _ref3.send
            }).on, send = _ref.send, globalStore("builtinListeners").getOrSet("functionCalls", (function() {
                return on("postrobot_method", {
                    domain: "*"
                }, (function(_ref2) {
                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
                    var id = data.id, name = data.name;
                    var meth = lookupMethod(source, id);
                    if (!meth) throw new Error("Could not find method '" + name + "' with id: " + data.id + " in " + Object(src.h)(window));
                    var methodSource = meth.source, domain = meth.domain, val = meth.val;
                    return zalgo_promise_src.a.try((function() {
                        if (!Object(src.x)(domain, origin)) throw new Error("Method '" + data.name + "' domain " + JSON.stringify(Object(belter_src.isRegex)(meth.domain) ? meth.domain.source : meth.domain) + " does not match origin " + origin + " in " + Object(src.h)(window));
                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {
                            send: send
                        }).then((function(match) {
                            if (!match) throw new Error("Method call '" + data.name + "' failed - proxy window does not match source in " + Object(src.h)(window));
                        }));
                    })).then((function() {
                        return val.apply({
                            source: source,
                            origin: origin
                        }, data.args);
                    }), (function(err) {
                        return zalgo_promise_src.a.try((function() {
                            if (val.onError) return val.onError(err);
                        })).then((function() {
                            err.stack && (err.stack = "Remote call to " + name + "(" + function(args) {
                                void 0 === args && (args = []);
                                return Object(belter_src.arrayFrom)(args).map((function(arg) {
                                    return "string" == typeof arg ? "'" + arg + "'" : void 0 === arg ? "undefined" : null === arg ? "null" : "boolean" == typeof arg ? arg.toString() : Array.isArray(arg) ? "[ ... ]" : "object" == typeof arg ? "{ ... }" : "function" == typeof arg ? "() => { ... }" : "<" + typeof arg + ">";
                                })).join(", ");
                            }(data.args) + ") failed\n\n" + err.stack);
                            throw err;
                        }));
                    })).then((function(result) {
                        return {
                            result: result,
                            id: id,
                            name: name
                        };
                    }));
                }));
            }));
            var _ref, on, send;
            var id = val.__id__ || Object(belter_src.uniqueID)();
            destination = window_ProxyWindow.unwrap(destination);
            var name = val.__name__ || val.name || key;
            "string" == typeof name && "function" == typeof name.indexOf && 0 === name.indexOf("anonymous::") && (name = name.replace("anonymous::", key + "::"));
            if (window_ProxyWindow.isProxyWindow(destination)) {
                addMethod(id, val, name, destination, domain);
                destination.awaitWindow().then((function(win) {
                    addMethod(id, val, name, win, domain);
                }));
            } else addMethod(id, val, name, destination, domain);
            return serializeType("cross_domain_function", {
                id: id,
                name: name
            });
        }
        function serializeMessage(destination, domain, obj, _ref) {
            var _serialize;
            var on = _ref.on, send = _ref.send;
            return function(obj, serializers) {
                void 0 === serializers && (serializers = defaultSerializers);
                var result = JSON.stringify(obj, (function(key) {
                    var val = this[key];
                    if (isSerializedType(this)) return val;
                    var type = determineType(val);
                    if (!type) return val;
                    var serializer = serializers[type] || SERIALIZER[type];
                    return serializer ? serializer(val, key) : val;
                }));
                return void 0 === result ? "undefined" : result;
            }(obj, ((_serialize = {}).promise = function(val, key) {
                return function(destination, domain, val, key, _ref) {
                    return serializeType("cross_domain_zalgo_promise", {
                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {
                            return val.then(resolve, reject);
                        }), key, {
                            on: _ref.on,
                            send: _ref.send
                        })
                    });
                }(destination, domain, val, key, {
                    on: on,
                    send: send
                });
            }, _serialize.function = function(val, key) {
                return function_serializeFunction(destination, domain, val, key, {
                    on: on,
                    send: send
                });
            }, _serialize.object = function(val) {
                return Object(src.u)(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType("cross_domain_window", window_ProxyWindow.serialize(val, {
                    send: send
                })) : val;
            }, _serialize));
        }
        function deserializeMessage(source, origin, message, _ref2) {
            var _deserialize;
            var send = _ref2.send;
            return function(str, deserializers) {
                void 0 === deserializers && (deserializers = defaultDeserializers);
                if ("undefined" !== str) return JSON.parse(str, (function(key, val) {
                    if (isSerializedType(this)) return val;
                    var type;
                    var value;
                    if (isSerializedType(val)) {
                        type = val.__type__;
                        value = val.__val__;
                    } else {
                        type = determineType(val);
                        value = val;
                    }
                    if (!type) return value;
                    var deserializer = deserializers[type] || DESERIALIZER[type];
                    return deserializer ? deserializer(value, key) : value;
                }));
            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {
                return function(source, origin, _ref2) {
                    return new zalgo_promise_src.a(_ref2.then);
                }(0, 0, serializedPromise);
            }, _deserialize.cross_domain_function = function(serializedFunction) {
                return function(source, origin, _ref4, _ref5) {
                    var id = _ref4.id, name = _ref4.name;
                    var send = _ref5.send;
                    var getDeserializedFunction = function(opts) {
                        void 0 === opts && (opts = {});
                        function crossDomainFunctionWrapper() {
                            var _arguments = arguments;
                            return window_ProxyWindow.toProxyWindow(source, {
                                send: send
                            }).awaitWindow().then((function(win) {
                                var meth = lookupMethod(win, id);
                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({
                                    source: window,
                                    origin: Object(src.h)()
                                }, _arguments);
                                var _args = [].slice.call(_arguments);
                                return opts.fireAndForget ? send(win, "postrobot_method", {
                                    id: id,
                                    name: name,
                                    args: _args
                                }, {
                                    domain: origin,
                                    fireAndForget: !0
                                }) : send(win, "postrobot_method", {
                                    id: id,
                                    name: name,
                                    args: _args
                                }, {
                                    domain: origin,
                                    fireAndForget: !1
                                }).then((function(res) {
                                    return res.data.result;
                                }));
                            })).catch((function(err) {
                                throw err;
                            }));
                        }
                        crossDomainFunctionWrapper.__name__ = name;
                        crossDomainFunctionWrapper.__origin__ = origin;
                        crossDomainFunctionWrapper.__source__ = source;
                        crossDomainFunctionWrapper.__id__ = id;
                        crossDomainFunctionWrapper.origin = origin;
                        return crossDomainFunctionWrapper;
                    };
                    var crossDomainFunctionWrapper = getDeserializedFunction();
                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({
                        fireAndForget: !0
                    });
                    return crossDomainFunctionWrapper;
                }(source, origin, serializedFunction, {
                    send: send
                });
            }, _deserialize.cross_domain_window = function(serializedWindow) {
                return window_ProxyWindow.deserialize(serializedWindow, {
                    send: send
                });
            }, _deserialize));
        }
        var SEND_MESSAGE_STRATEGIES = {};
        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {
            0 === domain.indexOf(src.a.FILE) && (domain = "*");
            win.postMessage(serializedMessage, domain);
        };
        SEND_MESSAGE_STRATEGIES.postrobot_bridge = function(win, serializedMessage, domain) {
            if (!needsBridgeForBrowser() && !isBridge()) throw new Error("Bridge not needed for browser");
            if (Object(src.s)(win)) throw new Error("Post message through bridge disabled between same domain windows");
            if (!1 !== Object(src.t)(window, win)) throw new Error("Can only use bridge to communicate between two different windows, not between frames");
            !function(win, domain, message) {
                var messagingChild = Object(src.r)(window, win);
                var messagingParent = Object(src.r)(win, window);
                if (!messagingChild && !messagingParent) throw new Error("Can only send messages to and from parent and popup windows");
                findRemoteWindow(win).then((function(sendMessage) {
                    return sendMessage(win, domain, message);
                }));
            }(win, domain, serializedMessage);
        };
        SEND_MESSAGE_STRATEGIES.postrobot_global = function(win, serializedMessage) {
            if (!Object(src.o)(window).match(/MSIE|rv:11|trident|edge\/12|edge\/13/i)) throw new Error("Global messaging not needed for browser");
            if (!Object(src.s)(win)) throw new Error("Post message through global disabled between different domain windows");
            if (!1 !== Object(src.t)(window, win)) throw new Error("Can only use global to communicate between two different windows, not between frames");
            var foreignGlobal = getGlobal(win);
            if (!foreignGlobal) throw new Error("Can not find postRobot global on foreign window");
            foreignGlobal.receiveMessage({
                source: window,
                origin: Object(src.h)(),
                data: serializedMessage
            });
        };
        function send_sendMessage(win, domain, message, _ref2) {
            var on = _ref2.on, send = _ref2.send;
            return zalgo_promise_src.a.try((function() {
                var domainBuffer = windowStore().getOrSet(win, (function() {
                    return {};
                }));
                domainBuffer.buffer = domainBuffer.buffer || [];
                domainBuffer.buffer.push(message);
                domainBuffer.flush = domainBuffer.flush || zalgo_promise_src.a.flush().then((function() {
                    if (Object(src.v)(win)) throw new Error("Window is closed");
                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_42__ = domainBuffer.buffer || [], 
                    _ref), {
                        on: on,
                        send: send
                    });
                    var _ref;
                    delete domainBuffer.buffer;
                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);
                    var errors = [];
                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {
                        var strategyName = strategies[_i2];
                        try {
                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);
                        } catch (err) {
                            errors.push(err);
                        }
                    }
                    if (errors.length === strategies.length) throw new Error("All post-robot messaging strategies failed:\n\n" + errors.map((function(err, i) {
                        return i + ". " + Object(belter_src.stringifyError)(err);
                    })).join("\n\n"));
                }));
                return domainBuffer.flush.then((function() {
                    delete domainBuffer.flush;
                }));
            })).then(belter_src.noop);
        }
        function getResponseListener(hash) {
            return globalStore("responseListeners").get(hash);
        }
        function deleteResponseListener(hash) {
            globalStore("responseListeners").del(hash);
        }
        function isResponseListenerErrored(hash) {
            return globalStore("erroredResponseListeners").has(hash);
        }
        function getRequestListener(_ref) {
            var name = _ref.name, win = _ref.win, domain = _ref.domain;
            var requestListeners = windowStore("requestListeners");
            "*" === win && (win = null);
            "*" === domain && (domain = null);
            if (!name) throw new Error("Name required to get request listener");
            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {
                var winQualifier = _ref3[_i4];
                if (winQualifier) {
                    var nameListeners = requestListeners.get(winQualifier);
                    if (nameListeners) {
                        var domainListeners = nameListeners[name];
                        if (domainListeners) {
                            if (domain && "string" == typeof domain) {
                                if (domainListeners[domain]) return domainListeners[domain];
                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {
                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], regex = _domainListeners$__DO3.regex, listener = _domainListeners$__DO3.listener;
                                    if (Object(src.x)(regex, domain)) return listener;
                                }
                            }
                            if (domainListeners["*"]) return domainListeners["*"];
                        }
                    }
                }
            }
        }
        function handleRequest(source, origin, message, _ref) {
            var on = _ref.on, send = _ref.send;
            var options = getRequestListener({
                name: message.name,
                win: source,
                domain: origin
            });
            var logName = "postrobot_method" === message.name && message.data && "string" == typeof message.data.name ? message.data.name + "()" : message.name;
            function sendResponse(ack, data, error) {
                return zalgo_promise_src.a.flush().then((function() {
                    if (!message.fireAndForget && !Object(src.v)(source)) try {
                        return send_sendMessage(source, origin, {
                            id: Object(belter_src.uniqueID)(),
                            origin: Object(src.h)(window),
                            type: "postrobot_message_response",
                            hash: message.hash,
                            name: message.name,
                            ack: ack,
                            data: data,
                            error: error
                        }, {
                            on: on,
                            send: send
                        });
                    } catch (err) {
                        throw new Error("Send response message failed for " + logName + " in " + Object(src.h)() + "\n\n" + Object(belter_src.stringifyError)(err));
                    }
                }));
            }
            return zalgo_promise_src.a.all([ zalgo_promise_src.a.flush().then((function() {
                if (!message.fireAndForget && !Object(src.v)(source)) try {
                    return send_sendMessage(source, origin, {
                        id: Object(belter_src.uniqueID)(),
                        origin: Object(src.h)(window),
                        type: "postrobot_message_ack",
                        hash: message.hash,
                        name: message.name
                    }, {
                        on: on,
                        send: send
                    });
                } catch (err) {
                    throw new Error("Send ack message failed for " + logName + " in " + Object(src.h)() + "\n\n" + Object(belter_src.stringifyError)(err));
                }
            })), zalgo_promise_src.a.try((function() {
                if (!options) throw new Error("No handler found for post message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                if (!Object(src.x)(options.domain, origin)) throw new Error("Request origin " + origin + " does not match domain " + options.domain.toString());
                return options.handler({
                    source: source,
                    origin: origin,
                    data: message.data
                });
            })).then((function(data) {
                return sendResponse("success", data);
            }), (function(error) {
                return sendResponse("error", null, error);
            })) ]).then(belter_src.noop).catch((function(err) {
                if (options && options.handleError) return options.handleError(err);
                throw err;
            }));
        }
        function handleAck(source, origin, message) {
            if (!isResponseListenerErrored(message.hash)) {
                var options = getResponseListener(message.hash);
                if (!options) throw new Error("No handler found for post message ack for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                try {
                    if (!Object(src.x)(options.domain, origin)) throw new Error("Ack origin " + origin + " does not match domain " + options.domain.toString());
                    if (source !== options.win) throw new Error("Ack source does not match registered window");
                } catch (err) {
                    options.promise.reject(err);
                }
                options.ack = !0;
            }
        }
        function handleResponse(source, origin, message) {
            if (!isResponseListenerErrored(message.hash)) {
                var options = getResponseListener(message.hash);
                if (!options) throw new Error("No handler found for post message response for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                if (!Object(src.x)(options.domain, origin)) throw new Error("Response origin " + origin + " does not match domain " + Object(src.A)(options.domain));
                if (source !== options.win) throw new Error("Response source does not match registered window");
                deleteResponseListener(message.hash);
                "error" === message.ack ? options.promise.reject(message.error) : "success" === message.ack && options.promise.resolve({
                    source: source,
                    origin: origin,
                    data: message.data
                });
            }
        }
        function receive_receiveMessage(event, _ref2) {
            var on = _ref2.on, send = _ref2.send;
            var receivedMessages = globalStore("receivedMessages");
            try {
                if (!window || window.closed || !event.source) return;
            } catch (err) {
                return;
            }
            var source = event.source, origin = event.origin;
            var messages = function(message, source, origin, _ref) {
                var on = _ref.on, send = _ref.send;
                var parsedMessage;
                try {
                    parsedMessage = deserializeMessage(source, origin, message, {
                        on: on,
                        send: send
                    });
                } catch (err) {
                    return;
                }
                if (parsedMessage && "object" == typeof parsedMessage && null !== parsedMessage) {
                    var parseMessages = parsedMessage.__post_robot_10_0_42__;
                    if (Array.isArray(parseMessages)) return parseMessages;
                }
            }(event.data, source, origin, {
                on: on,
                send: send
            });
            if (messages) {
                markWindowKnown(source);
                for (var _i2 = 0; _i2 < messages.length; _i2++) {
                    var message = messages[_i2];
                    if (receivedMessages.has(message.id)) return;
                    receivedMessages.set(message.id, !0);
                    if (Object(src.v)(source) && !message.fireAndForget) return;
                    0 === message.origin.indexOf(src.a.FILE) && (origin = src.a.FILE + "//");
                    try {
                        "postrobot_message_request" === message.type ? handleRequest(source, origin, message, {
                            on: on,
                            send: send
                        }) : "postrobot_message_response" === message.type ? handleResponse(source, origin, message) : "postrobot_message_ack" === message.type && handleAck(source, origin, message);
                    } catch (err) {
                        setTimeout((function() {
                            throw err;
                        }), 0);
                    }
                }
            }
        }
        function on_on(name, options, handler) {
            if (!name) throw new Error("Expected name");
            if ("function" == typeof (options = options || {})) {
                handler = options;
                options = {};
            }
            if (!handler) throw new Error("Expected handler");
            (options = options || {}).name = name;
            options.handler = handler || options.handler;
            var win = options.window;
            var domain = options.domain;
            var requestListener = function addRequestListener(_ref4, listener) {
                var name = _ref4.name, win = _ref4.win, domain = _ref4.domain;
                var requestListeners = windowStore("requestListeners");
                if (!name || "string" != typeof name) throw new Error("Name required to add request listener");
                if (Array.isArray(win)) {
                    var listenersCollection = [];
                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({
                        name: name,
                        domain: domain,
                        win: _win2[_i8]
                    }, listener));
                    return {
                        cancel: function() {
                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();
                        }
                    };
                }
                if (Array.isArray(domain)) {
                    var _listenersCollection = [];
                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({
                        name: name,
                        win: win,
                        domain: _domain2[_i12]
                    }, listener));
                    return {
                        cancel: function() {
                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();
                        }
                    };
                }
                var existingListener = getRequestListener({
                    name: name,
                    win: win,
                    domain: domain
                });
                win && "*" !== win || (win = getWildcard());
                domain = domain || "*";
                if (existingListener) throw win && domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString() + " for " + (win === getWildcard() ? "wildcard" : "specified") + " window") : win ? new Error("Request listener already exists for " + name + " for " + (win === getWildcard() ? "wildcard" : "specified") + " window") : domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString()) : new Error("Request listener already exists for " + name);
                var nameListeners = requestListeners.getOrSet(win, (function() {
                    return {};
                }));
                var domainListeners = Object(belter_src.getOrSet)(nameListeners, name, (function() {
                    return {};
                }));
                var strDomain = domain.toString();
                var regexListeners;
                var regexListener;
                Object(belter_src.isRegex)(domain) ? (regexListeners = Object(belter_src.getOrSet)(domainListeners, "__domain_regex__", (function() {
                    return [];
                }))).push(regexListener = {
                    regex: domain,
                    listener: listener
                }) : domainListeners[strDomain] = listener;
                return {
                    cancel: function() {
                        delete domainListeners[strDomain];
                        if (regexListener) {
                            regexListeners.splice(regexListeners.indexOf(regexListener, 1));
                            regexListeners.length || delete domainListeners.__domain_regex__;
                        }
                        Object.keys(domainListeners).length || delete nameListeners[name];
                        win && !Object.keys(nameListeners).length && requestListeners.del(win);
                    }
                };
            }({
                name: name,
                win: win,
                domain: domain
            }, {
                handler: options.handler,
                handleError: options.errorHandler || function(err) {
                    throw err;
                },
                window: win,
                domain: domain || "*",
                name: name
            });
            return {
                cancel: function() {
                    requestListener.cancel();
                }
            };
        }
        var send_send = function send(win, name, data, options) {
            var domainMatcher = (options = options || {}).domain || "*";
            var responseTimeout = options.timeout || -1;
            var childTimeout = options.timeout || 5e3;
            var fireAndForget = options.fireAndForget || !1;
            return zalgo_promise_src.a.try((function() {
                !function(name, win, domain) {
                    if (!name) throw new Error("Expected name");
                    if (domain && "string" != typeof domain && !Array.isArray(domain) && !Object(belter_src.isRegex)(domain)) throw new TypeError("Can not send " + name + ". Expected domain " + JSON.stringify(domain) + " to be a string, array, or regex");
                    if (Object(src.v)(win)) throw new Error("Can not send " + name + ". Target window is closed");
                }(name, win, domainMatcher);
                if (Object(src.p)(window, win)) return awaitWindowHello(win, childTimeout);
            })).then((function(_temp) {
                return function(win, targetDomain, actualDomain, _ref) {
                    var send = _ref.send;
                    return zalgo_promise_src.a.try((function() {
                        return "string" == typeof targetDomain ? targetDomain : zalgo_promise_src.a.try((function() {
                            return actualDomain || sayHello(win, {
                                send: send
                            }).then((function(_ref2) {
                                return _ref2.domain;
                            }));
                        })).then((function(normalizedDomain) {
                            if (!Object(src.x)(targetDomain, targetDomain)) throw new Error("Domain " + Object(belter_src.stringify)(targetDomain) + " does not match " + Object(belter_src.stringify)(targetDomain));
                            return normalizedDomain;
                        }));
                    }));
                }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {
                    send: send
                });
            })).then((function(targetDomain) {
                var domain = targetDomain;
                var logName = "postrobot_method" === name && data && "string" == typeof data.name ? data.name + "()" : name;
                var promise = new zalgo_promise_src.a;
                var hash = name + "_" + Object(belter_src.uniqueID)();
                if (!fireAndForget) {
                    var responseListener = {
                        name: name,
                        win: win,
                        domain: domain,
                        promise: promise
                    };
                    !function(hash, listener) {
                        globalStore("responseListeners").set(hash, listener);
                    }(hash, responseListener);
                    var reqPromises = windowStore("requestPromises").getOrSet(win, (function() {
                        return [];
                    }));
                    reqPromises.push(promise);
                    promise.catch((function() {
                        !function(hash) {
                            globalStore("erroredResponseListeners").set(hash, !0);
                        }(hash);
                        deleteResponseListener(hash);
                    }));
                    var totalAckTimeout = function(win) {
                        return windowStore("knownWindows").get(win, !1);
                    }(win) ? 1e4 : 2e3;
                    var totalResTimeout = responseTimeout;
                    var ackTimeout = totalAckTimeout;
                    var resTimeout = totalResTimeout;
                    var interval = Object(belter_src.safeInterval)((function() {
                        if (Object(src.v)(win)) return promise.reject(new Error("Window closed for " + name + " before " + (responseListener.ack ? "response" : "ack")));
                        if (responseListener.cancelled) return promise.reject(new Error("Response listener was cancelled for " + name));
                        ackTimeout = Math.max(ackTimeout - 500, 0);
                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));
                        return responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout ? promise.reject(new Error("No response for postMessage " + logName + " in " + Object(src.h)() + " in " + totalResTimeout + "ms")) : void 0 : promise.reject(new Error("No ack for postMessage " + logName + " in " + Object(src.h)() + " in " + totalAckTimeout + "ms"));
                    }), 500);
                    promise.finally((function() {
                        interval.cancel();
                        reqPromises.splice(reqPromises.indexOf(promise, 1));
                    })).catch(belter_src.noop);
                }
                return send_sendMessage(win, domain, {
                    id: Object(belter_src.uniqueID)(),
                    origin: Object(src.h)(window),
                    type: "postrobot_message_request",
                    hash: hash,
                    name: name,
                    data: data,
                    fireAndForget: fireAndForget
                }, {
                    on: on_on,
                    send: send
                }).then((function() {
                    return fireAndForget ? promise.resolve() : promise;
                }), (function(err) {
                    throw new Error("Send request message failed for " + logName + " in " + Object(src.h)() + "\n\n" + Object(belter_src.stringifyError)(err));
                }));
            }));
        };
        function setup_serializeMessage(destination, domain, obj) {
            return serializeMessage(destination, domain, obj, {
                on: on_on,
                send: send_send
            });
        }
        function setup_deserializeMessage(source, origin, message) {
            return deserializeMessage(source, origin, message, {
                on: on_on,
                send: send_send
            });
        }
        function setup_toProxyWindow(win) {
            return window_ProxyWindow.toProxyWindow(win, {
                send: send_send
            });
        }
        function setup() {
            if (!getGlobal().initialized) {
                getGlobal().initialized = !0;
                !function(_ref3) {
                    var on = _ref3.on, send = _ref3.send;
                    var global = getGlobal();
                    global.receiveMessage = global.receiveMessage || function(message) {
                        return receive_receiveMessage(message, {
                            on: on,
                            send: send
                        });
                    };
                }({
                    on: on_on,
                    send: send_send
                });
                on = (_ref5 = {
                    on: on_on,
                    send: send_send
                }).on, send = _ref5.send, globalStore().getOrSet("postMessageListener", (function() {
                    return Object(belter_src.addEventListener)(window, "message", (function(event) {
                        !function(event, _ref4) {
                            var on = _ref4.on, send = _ref4.send;
                            zalgo_promise_src.a.try((function() {
                                try {
                                    Object(belter_src.noop)(event.source);
                                } catch (err) {
                                    return;
                                }
                                var source = event.source || event.sourceElement;
                                var origin = event.origin || event.originalEvent && event.originalEvent.origin;
                                var data = event.data;
                                "null" === origin && (origin = src.a.FILE + "//");
                                if (source) {
                                    if (!origin) throw new Error("Post message did not have origin domain");
                                    receive_receiveMessage({
                                        source: source,
                                        origin: origin,
                                        data: data
                                    }, {
                                        on: on,
                                        send: send
                                    });
                                }
                            }));
                        }(event, {
                            on: on,
                            send: send
                        });
                    }));
                }));
                setupBridge({
                    on: on_on,
                    send: send_send,
                    receiveMessage: receive_receiveMessage
                });
                !function(_ref8) {
                    var on = _ref8.on, send = _ref8.send;
                    globalStore("builtinListeners").getOrSet("helloListener", (function() {
                        var listener = on("postrobot_hello", {
                            domain: "*"
                        }, (function(_ref3) {
                            resolveHelloPromise(_ref3.source, {
                                domain: _ref3.origin
                            });
                            return {
                                instanceID: getInstanceID()
                            };
                        }));
                        var parent = Object(src.f)();
                        parent && sayHello(parent, {
                            send: send
                        }).catch((function(err) {}));
                        return listener;
                    }));
                }({
                    on: on_on,
                    send: send_send
                });
            }
            var _ref5, on, send;
        }
        function destroy() {
            !function() {
                var responseListeners = globalStore("responseListeners");
                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {
                    var hash = _responseListeners$ke2[_i2];
                    var listener = responseListeners.get(hash);
                    listener && (listener.cancelled = !0);
                    responseListeners.del(hash);
                }
            }();
            (listener = globalStore().get("postMessageListener")) && listener.cancel();
            var listener;
            delete window.__post_robot_10_0_42__;
        }
        function cleanUpWindow(win) {
            for (var _i2 = 0, _requestPromises$get2 = windowStore("requestPromises").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error("Window " + (Object(src.v)(win) ? "closed" : "cleaned up") + " before response")).catch(belter_src.noop);
        }
        var src_bridge;
        src_bridge = {
            setupBridge: setupBridge,
            openBridge: function(url, domain) {
                var bridges = globalStore("bridges");
                var bridgeFrames = globalStore("bridgeFrames");
                domain = domain || Object(src.i)(url);
                return bridges.getOrSet(domain, (function() {
                    return zalgo_promise_src.a.try((function() {
                        if (Object(src.h)() === domain) throw new Error("Can not open bridge on the same domain as current domain: " + domain);
                        var name = getBridgeName(domain);
                        if (Object(src.j)(window, name)) throw new Error("Frame with name " + name + " already exists on page");
                        var iframe = function(name, url) {
                            var iframe = document.createElement("iframe");
                            iframe.setAttribute("name", name);
                            iframe.setAttribute("id", name);
                            iframe.setAttribute("style", "display: none; margin: 0; padding: 0; border: 0px none; overflow: hidden;");
                            iframe.setAttribute("frameborder", "0");
                            iframe.setAttribute("border", "0");
                            iframe.setAttribute("scrolling", "no");
                            iframe.setAttribute("allowTransparency", "true");
                            iframe.setAttribute("tabindex", "-1");
                            iframe.setAttribute("hidden", "true");
                            iframe.setAttribute("title", "");
                            iframe.setAttribute("role", "presentation");
                            iframe.src = url;
                            return iframe;
                        }(name, url);
                        bridgeFrames.set(domain, iframe);
                        return documentBodyReady.then((function(body) {
                            body.appendChild(iframe);
                            var bridge = iframe.contentWindow;
                            return new zalgo_promise_src.a((function(resolve, reject) {
                                iframe.addEventListener("load", resolve);
                                iframe.addEventListener("error", reject);
                            })).then((function() {
                                return awaitWindowHello(bridge, 5e3, "Bridge " + url);
                            })).then((function() {
                                return bridge;
                            }));
                        }));
                    }));
                }));
            },
            linkWindow: linkWindow,
            linkUrl: function(win, url) {
                linkWindow({
                    win: win,
                    domain: Object(src.i)(url)
                });
            },
            isBridge: isBridge,
            needsBridge: needsBridge,
            needsBridgeForBrowser: needsBridgeForBrowser,
            hasBridge: function(url, domain) {
                return globalStore("bridges").has(domain || Object(src.i)(url));
            },
            needsBridgeForWin: needsBridgeForWin,
            needsBridgeForDomain: needsBridgeForDomain,
            destroyBridges: function() {
                var bridges = globalStore("bridges");
                var bridgeFrames = globalStore("bridgeFrames");
                for (var _i4 = 0, _bridgeFrames$keys2 = bridgeFrames.keys(); _i4 < _bridgeFrames$keys2.length; _i4++) {
                    var frame = bridgeFrames.get(_bridgeFrames$keys2[_i4]);
                    frame && frame.parentNode && frame.parentNode.removeChild(frame);
                }
                bridgeFrames.reset();
                bridges.reset();
            }
        };
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return _extends;
        }));
        function _extends() {
            return (_extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) ({}).hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }).apply(this, arguments);
        }
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return getGlobal;
        }));
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return destroyGlobal;
        }));
        __webpack_require__.d(__webpack_exports__, "c", (function() {
            return getProxyObject;
        }));
        var src = __webpack_require__(0);
        __webpack_require__(1);
        function getGlobal(win) {
            void 0 === win && (win = window);
            if (!Object(src.s)(win)) throw new Error("Can not get global for window on different domain");
            win.__zoid_9_0_63__ || (win.__zoid_9_0_63__ = {});
            return win.__zoid_9_0_63__;
        }
        function destroyGlobal() {
            delete window.__zoid_9_0_63__;
        }
        var zalgo_promise_src = __webpack_require__(2);
        function getProxyObject(obj) {
            return {
                get: function() {
                    var _this = this;
                    return zalgo_promise_src.a.try((function() {
                        if (_this.source && _this.source !== window) throw new Error("Can not call get on proxy object from a remote window");
                        return obj;
                    }));
                }
            };
        }
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return weakmap_CrossDomainSafeWeakMap;
        }));
        var src = __webpack_require__(0);
        function safeIndexOf(collection, item) {
            for (var i = 0; i < collection.length; i++) try {
                if (collection[i] === item) return i;
            } catch (err) {}
            return -1;
        }
        var weakmap_CrossDomainSafeWeakMap = function() {
            function CrossDomainSafeWeakMap() {
                this.name = void 0;
                this.weakmap = void 0;
                this.keys = void 0;
                this.values = void 0;
                this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__";
                if (function() {
                    if ("undefined" == typeof WeakMap) return !1;
                    if (void 0 === Object.freeze) return !1;
                    try {
                        var testWeakMap = new WeakMap;
                        var testKey = {};
                        Object.freeze(testKey);
                        testWeakMap.set(testKey, "__testvalue__");
                        return "__testvalue__" === testWeakMap.get(testKey);
                    } catch (err) {
                        return !1;
                    }
                }()) try {
                    this.weakmap = new WeakMap;
                } catch (err) {}
                this.keys = [];
                this.values = [];
            }
            var _proto = CrossDomainSafeWeakMap.prototype;
            _proto._cleanupClosedWindows = function() {
                var weakmap = this.weakmap;
                var keys = this.keys;
                for (var i = 0; i < keys.length; i++) {
                    var value = keys[i];
                    if (Object(src.u)(value) && Object(src.v)(value)) {
                        if (weakmap) try {
                            weakmap.delete(value);
                        } catch (err) {}
                        keys.splice(i, 1);
                        this.values.splice(i, 1);
                        i -= 1;
                    }
                }
            };
            _proto.isSafeToReadWrite = function(key) {
                return !Object(src.u)(key);
            };
            _proto.set = function(key, value) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    weakmap.set(key, value);
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var name = this.name;
                    var entry = key[name];
                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {
                        value: [ key, value ],
                        writable: !0
                    });
                    return;
                } catch (err) {}
                this._cleanupClosedWindows();
                var keys = this.keys;
                var values = this.values;
                var index = safeIndexOf(keys, key);
                if (-1 === index) {
                    keys.push(key);
                    values.push(value);
                } else values[index] = value;
            };
            _proto.get = function(key) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    if (weakmap.has(key)) return weakmap.get(key);
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var entry = key[this.name];
                    return entry && entry[0] === key ? entry[1] : void 0;
                } catch (err) {}
                this._cleanupClosedWindows();
                var index = safeIndexOf(this.keys, key);
                if (-1 !== index) return this.values[index];
            };
            _proto.delete = function(key) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    weakmap.delete(key);
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var entry = key[this.name];
                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);
                } catch (err) {}
                this._cleanupClosedWindows();
                var keys = this.keys;
                var index = safeIndexOf(keys, key);
                if (-1 !== index) {
                    keys.splice(index, 1);
                    this.values.splice(index, 1);
                }
            };
            _proto.has = function(key) {
                if (!key) throw new Error("WeakMap expected key");
                var weakmap = this.weakmap;
                if (weakmap) try {
                    if (weakmap.has(key)) return !0;
                } catch (err) {
                    delete this.weakmap;
                }
                if (this.isSafeToReadWrite(key)) try {
                    var entry = key[this.name];
                    return !(!entry || entry[0] !== key);
                } catch (err) {}
                this._cleanupClosedWindows();
                return -1 !== safeIndexOf(this.keys, key);
            };
            _proto.getOrSet = function(key, getter) {
                if (this.has(key)) return this.get(key);
                var value = getter();
                this.set(key, value);
                return value;
            };
            return CrossDomainSafeWeakMap;
        }();
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return _inheritsLoose;
        }));
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
        }
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return parentComponent;
        }));
        var esm_extends = __webpack_require__(5);
        var src = __webpack_require__(4);
        var cross_domain_utils_src = __webpack_require__(0);
        var zalgo_promise_src = __webpack_require__(2);
        var belter_src = __webpack_require__(1);
        var constants = __webpack_require__(3);
        var lib = __webpack_require__(6);
        function getQueryParam(prop, key, value) {
            return zalgo_promise_src.a.try((function() {
                return "function" == typeof prop.queryParam ? prop.queryParam({
                    value: value
                }) : "string" == typeof prop.queryParam ? prop.queryParam : key;
            }));
        }
        function getQueryValue(prop, key, value) {
            return zalgo_promise_src.a.try((function() {
                return "function" == typeof prop.queryValue && Object(belter_src.isDefined)(value) ? prop.queryValue({
                    value: value
                }) : value;
            }));
        }
        function parentComponent(options, overrides, parentWin) {
            void 0 === overrides && (overrides = {});
            void 0 === parentWin && (parentWin = window);
            var propsDef = options.propsDef, containerTemplate = options.containerTemplate, prerenderTemplate = options.prerenderTemplate, tag = options.tag, name = options.name, attributes = options.attributes, dimensions = options.dimensions, autoResize = options.autoResize, url = options.url, domainMatch = options.domain;
            var initPromise = new zalgo_promise_src.a;
            var handledErrors = [];
            var clean = Object(belter_src.cleanup)();
            var state = {};
            var internalState = {
                visible: !0
            };
            var event = overrides.event ? overrides.event : Object(belter_src.eventEmitter)();
            var props = overrides.props ? overrides.props : {};
            var currentProxyWin;
            var currentProxyContainer;
            var childComponent;
            var onErrorOverride = overrides.onError;
            var getProxyContainerOverride = overrides.getProxyContainer;
            var showOverride = overrides.show;
            var hideOverride = overrides.hide;
            var closeOverride = overrides.close;
            var renderContainerOverride = overrides.renderContainer;
            var getProxyWindowOverride = overrides.getProxyWindow;
            var setProxyWinOverride = overrides.setProxyWin;
            var openFrameOverride = overrides.openFrame;
            var openPrerenderFrameOverride = overrides.openPrerenderFrame;
            var prerenderOverride = overrides.prerender;
            var openOverride = overrides.open;
            var openPrerenderOverride = overrides.openPrerender;
            var watchForUnloadOverride = overrides.watchForUnload;
            var getInternalStateOverride = overrides.getInternalState;
            var setInternalStateOverride = overrides.setInternalState;
            var getPropsForChild = function(domain) {
                var result = {};
                for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {
                    var key = _Object$keys2[_i2];
                    var prop = propsDef[key];
                    prop && !1 === prop.sendToChild || prop && prop.sameDomain && !Object(cross_domain_utils_src.x)(domain, Object(cross_domain_utils_src.h)(window)) || (result[key] = props[key]);
                }
                return zalgo_promise_src.a.hash(result);
            };
            var getInternalState = function() {
                return zalgo_promise_src.a.try((function() {
                    return getInternalStateOverride ? getInternalStateOverride() : internalState;
                }));
            };
            var setInternalState = function(newInternalState) {
                return zalgo_promise_src.a.try((function() {
                    return setInternalStateOverride ? setInternalStateOverride(newInternalState) : internalState = Object(esm_extends.a)({}, internalState, newInternalState);
                }));
            };
            var getProxyWindow = function() {
                return getProxyWindowOverride ? getProxyWindowOverride() : zalgo_promise_src.a.try((function() {
                    var windowProp = props.window;
                    if (windowProp) {
                        var _proxyWin = Object(src.k)(windowProp);
                        clean.register((function() {
                            return windowProp.close();
                        }));
                        return _proxyWin;
                    }
                    return new src.a({
                        send: src.h
                    });
                }));
            };
            var getProxyContainer = function(container) {
                return getProxyContainerOverride ? getProxyContainerOverride(container) : zalgo_promise_src.a.try((function() {
                    return Object(belter_src.elementReady)(container);
                })).then((function(containerElement) {
                    Object(belter_src.isShadowElement)(containerElement) && (containerElement = Object(belter_src.insertShadowSlot)(containerElement));
                    return Object(lib.c)(containerElement);
                }));
            };
            var setProxyWin = function(proxyWin) {
                return setProxyWinOverride ? setProxyWinOverride(proxyWin) : zalgo_promise_src.a.try((function() {
                    currentProxyWin = proxyWin;
                }));
            };
            var show = function() {
                return showOverride ? showOverride() : zalgo_promise_src.a.hash({
                    setState: setInternalState({
                        visible: !0
                    }),
                    showElement: currentProxyContainer ? currentProxyContainer.get().then(belter_src.showElement) : null
                }).then(belter_src.noop);
            };
            var hide = function() {
                return hideOverride ? hideOverride() : zalgo_promise_src.a.hash({
                    setState: setInternalState({
                        visible: !1
                    }),
                    showElement: currentProxyContainer ? currentProxyContainer.get().then(belter_src.hideElement) : null
                }).then(belter_src.noop);
            };
            var getUrl = function() {
                return "function" == typeof url ? url({
                    props: props
                }) : url;
            };
            var getAttributes = function() {
                return "function" == typeof attributes ? attributes({
                    props: props
                }) : attributes;
            };
            var getChildDomain = function() {
                return domainMatch && "string" == typeof domainMatch ? domainMatch : Object(cross_domain_utils_src.i)(getUrl());
            };
            var getDomainMatcher = function() {
                return domainMatch && Object(belter_src.isRegex)(domainMatch) ? domainMatch : getChildDomain();
            };
            var openFrame = function(context, _ref) {
                var windowName = _ref.windowName;
                return openFrameOverride ? openFrameOverride(context, {
                    windowName: windowName
                }) : zalgo_promise_src.a.try((function() {
                    if (context === constants.CONTEXT.IFRAME) {
                        var attrs = Object(esm_extends.a)({
                            name: windowName,
                            title: name
                        }, getAttributes().iframe);
                        return Object(lib.c)(Object(belter_src.iframe)({
                            attributes: attrs
                        }));
                    }
                }));
            };
            var openPrerenderFrame = function(context) {
                return openPrerenderFrameOverride ? openPrerenderFrameOverride(context) : zalgo_promise_src.a.try((function() {
                    if (context === constants.CONTEXT.IFRAME) {
                        var attrs = Object(esm_extends.a)({
                            name: "__" + constants.ZOID + "_prerender_frame__" + name + "_" + Object(belter_src.uniqueID)() + "__",
                            title: "prerender__" + name
                        }, getAttributes().iframe);
                        return Object(lib.c)(Object(belter_src.iframe)({
                            attributes: attrs
                        }));
                    }
                }));
            };
            var openPrerender = function(context, proxyWin, proxyPrerenderFrame) {
                return openPrerenderOverride ? openPrerenderOverride(context, proxyWin, proxyPrerenderFrame) : zalgo_promise_src.a.try((function() {
                    if (context === constants.CONTEXT.IFRAME) {
                        if (!proxyPrerenderFrame) throw new Error("Expected proxy frame to be passed");
                        return proxyPrerenderFrame.get().then((function(prerenderFrame) {
                            clean.register((function() {
                                return Object(belter_src.destroyElement)(prerenderFrame);
                            }));
                            return Object(belter_src.awaitFrameWindow)(prerenderFrame).then((function(prerenderFrameWindow) {
                                return Object(cross_domain_utils_src.c)(prerenderFrameWindow);
                            })).then((function(win) {
                                return Object(src.k)(win);
                            }));
                        }));
                    }
                    if (context === constants.CONTEXT.POPUP) return proxyWin;
                    throw new Error("No render context available for " + context);
                }));
            };
            var focus = function() {
                return zalgo_promise_src.a.try((function() {
                    if (currentProxyWin) return zalgo_promise_src.a.all([ event.trigger(constants.EVENT.FOCUS), currentProxyWin.focus() ]).then(belter_src.noop);
                }));
            };
            var getWindowRef = function(target, domain, uid, context) {
                if (domain === Object(cross_domain_utils_src.h)(window)) {
                    var global = Object(lib.b)(window);
                    global.windows = global.windows || {};
                    global.windows[uid] = window;
                    clean.register((function() {
                        delete global.windows[uid];
                    }));
                    return {
                        type: constants.WINDOW_REFERENCES.GLOBAL,
                        uid: uid
                    };
                }
                return context === constants.CONTEXT.POPUP ? {
                    type: constants.WINDOW_REFERENCES.OPENER
                } : {
                    type: constants.WINDOW_REFERENCES.PARENT,
                    distance: Object(cross_domain_utils_src.g)(window)
                };
            };
            var initChild = function(childExports) {
                return zalgo_promise_src.a.try((function() {
                    childComponent = childExports;
                    initPromise.resolve();
                    clean.register((function() {
                        return childExports.close.fireAndForget().catch(belter_src.noop);
                    }));
                }));
            };
            var resize = function(_ref2) {
                var width = _ref2.width, height = _ref2.height;
                return zalgo_promise_src.a.try((function() {
                    event.trigger(constants.EVENT.RESIZE, {
                        width: width,
                        height: height
                    });
                }));
            };
            var destroy = function(err) {
                return zalgo_promise_src.a.try((function() {
                    return event.trigger(constants.EVENT.DESTROY);
                })).catch(belter_src.noop).then((function() {
                    return clean.all();
                })).then((function() {
                    initPromise.asyncReject(err || new Error("Component destroyed"));
                }));
            };
            var close = Object(belter_src.memoize)((function() {
                return zalgo_promise_src.a.try((function() {
                    if (closeOverride) {
                        var source = closeOverride.__source__;
                        if (Object(cross_domain_utils_src.v)(source)) return;
                        return closeOverride();
                    }
                    return zalgo_promise_src.a.try((function() {
                        return event.trigger(constants.EVENT.CLOSE);
                    })).then((function() {
                        return destroy(new Error("Window closed"));
                    }));
                }));
            }));
            var open = function(context, _ref3) {
                var proxyWin = _ref3.proxyWin, proxyFrame = _ref3.proxyFrame, windowName = _ref3.windowName;
                return openOverride ? openOverride(context, {
                    proxyWin: proxyWin,
                    proxyFrame: proxyFrame,
                    windowName: windowName
                }) : zalgo_promise_src.a.try((function() {
                    if (context === constants.CONTEXT.IFRAME) {
                        if (!proxyFrame) throw new Error("Expected proxy frame to be passed");
                        return proxyFrame.get().then((function(frame) {
                            return Object(belter_src.awaitFrameWindow)(frame).then((function(win) {
                                clean.register((function() {
                                    return Object(belter_src.destroyElement)(frame);
                                }));
                                clean.register((function() {
                                    return Object(src.c)(win);
                                }));
                                return win;
                            }));
                        }));
                    }
                    if (context === constants.CONTEXT.POPUP) {
                        var width = dimensions.width, height = dimensions.height;
                        width = Object(belter_src.normalizeDimension)(width, window.outerWidth);
                        height = Object(belter_src.normalizeDimension)(height, window.outerWidth);
                        var attrs = Object(esm_extends.a)({
                            name: windowName,
                            width: width,
                            height: height
                        }, getAttributes().popup);
                        var win = Object(belter_src.popup)("", attrs);
                        clean.register((function() {
                            return Object(cross_domain_utils_src.d)(win);
                        }));
                        clean.register((function() {
                            return Object(src.c)(win);
                        }));
                        return win;
                    }
                    throw new Error("No render context available for " + context);
                })).then((function(win) {
                    proxyWin.setWindow(win, {
                        send: src.h
                    });
                    return proxyWin;
                }));
            };
            var watchForUnload = function() {
                return zalgo_promise_src.a.try((function() {
                    var unloadWindowListener = Object(belter_src.addEventListener)(window, "unload", Object(belter_src.once)((function() {
                        destroy(new Error("Window navigated away"));
                    })));
                    var closeParentWindowListener = Object(cross_domain_utils_src.z)(parentWin, destroy, 3e3);
                    clean.register(closeParentWindowListener.cancel);
                    clean.register(unloadWindowListener.cancel);
                    if (watchForUnloadOverride) return watchForUnloadOverride();
                }));
            };
            var checkWindowClose = function(proxyWin) {
                var closed = !1;
                return proxyWin.isClosed().then((function(isClosed) {
                    if (isClosed) {
                        closed = !0;
                        return close();
                    }
                    return zalgo_promise_src.a.delay(200).then((function() {
                        return proxyWin.isClosed();
                    })).then((function(secondIsClosed) {
                        if (secondIsClosed) {
                            closed = !0;
                            return close();
                        }
                    }));
                })).then((function() {
                    return closed;
                }));
            };
            var onError = function(err) {
                return onErrorOverride ? onErrorOverride(err) : zalgo_promise_src.a.try((function() {
                    if (-1 === handledErrors.indexOf(err)) {
                        handledErrors.push(err);
                        initPromise.asyncReject(err);
                        return event.trigger(constants.EVENT.ERROR, err);
                    }
                }));
            };
            initChild.onError = onError;
            var renderTemplate = function(renderer, _ref6) {
                return renderer({
                    container: _ref6.container,
                    context: _ref6.context,
                    uid: _ref6.uid,
                    doc: _ref6.doc,
                    frame: _ref6.frame,
                    prerenderFrame: _ref6.prerenderFrame,
                    focus: focus,
                    close: close,
                    state: state,
                    props: props,
                    tag: tag,
                    dimensions: dimensions,
                    event: event
                });
            };
            var prerender = function(proxyPrerenderWin, _ref7) {
                var context = _ref7.context, uid = _ref7.uid;
                return prerenderOverride ? prerenderOverride(proxyPrerenderWin, {
                    context: context,
                    uid: uid
                }) : zalgo_promise_src.a.try((function() {
                    if (prerenderTemplate) {
                        var prerenderWindow = proxyPrerenderWin.getWindow();
                        if (prerenderWindow && Object(cross_domain_utils_src.s)(prerenderWindow) && Object(cross_domain_utils_src.q)(prerenderWindow)) {
                            var doc = (prerenderWindow = Object(cross_domain_utils_src.c)(prerenderWindow)).document;
                            var el = renderTemplate(prerenderTemplate, {
                                context: context,
                                uid: uid,
                                doc: doc
                            });
                            if (el) {
                                if (el.ownerDocument !== doc) throw new Error("Expected prerender template to have been created with document from child window");
                                Object(belter_src.writeElementToWindow)(prerenderWindow, el);
                                var _autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, _autoResize$element = autoResize.element, element = void 0 === _autoResize$element ? "body" : _autoResize$element;
                                if ((element = Object(belter_src.getElementSafe)(element, doc)) && (width || height)) {
                                    var prerenderResizeListener = Object(belter_src.onResize)(element, (function(_ref8) {
                                        resize({
                                            width: width ? _ref8.width : void 0,
                                            height: height ? _ref8.height : void 0
                                        });
                                    }), {
                                        width: width,
                                        height: height,
                                        win: prerenderWindow
                                    });
                                    event.on(constants.EVENT.RENDERED, prerenderResizeListener.cancel);
                                }
                            }
                        }
                    }
                }));
            };
            var renderContainer = function(proxyContainer, _ref9) {
                var proxyFrame = _ref9.proxyFrame, proxyPrerenderFrame = _ref9.proxyPrerenderFrame, context = _ref9.context, uid = _ref9.uid;
                return renderContainerOverride ? renderContainerOverride(proxyContainer, {
                    proxyFrame: proxyFrame,
                    proxyPrerenderFrame: proxyPrerenderFrame,
                    context: context,
                    uid: uid
                }) : zalgo_promise_src.a.hash({
                    container: proxyContainer.get(),
                    frame: proxyFrame ? proxyFrame.get() : null,
                    prerenderFrame: proxyPrerenderFrame ? proxyPrerenderFrame.get() : null,
                    internalState: getInternalState()
                }).then((function(_ref10) {
                    var container = _ref10.container, visible = _ref10.internalState.visible;
                    var innerContainer = renderTemplate(containerTemplate, {
                        context: context,
                        uid: uid,
                        container: container,
                        frame: _ref10.frame,
                        prerenderFrame: _ref10.prerenderFrame,
                        doc: document
                    });
                    if (innerContainer) {
                        visible || Object(belter_src.hideElement)(innerContainer);
                        Object(belter_src.appendChild)(container, innerContainer);
                        var containerWatcher = Object(belter_src.watchElementForClose)(innerContainer, close);
                        clean.register((function() {
                            return containerWatcher.cancel();
                        }));
                        clean.register((function() {
                            return Object(belter_src.destroyElement)(innerContainer);
                        }));
                        return currentProxyContainer = Object(lib.c)(innerContainer);
                    }
                }));
            };
            var getHelpers = function() {
                return {
                    state: state,
                    event: event,
                    close: close,
                    focus: focus,
                    resize: resize,
                    onError: onError,
                    updateProps: updateProps,
                    show: show,
                    hide: hide
                };
            };
            var setProps = function(newProps, isUpdate) {
                void 0 === isUpdate && (isUpdate = !1);
                var helpers = getHelpers();
                !function(propsDef, props, inputProps, helpers, isUpdate) {
                    void 0 === isUpdate && (isUpdate = !1);
                    inputProps = inputProps || {};
                    Object(belter_src.extend)(props, inputProps);
                    var propNames = isUpdate ? [] : [].concat(Object.keys(propsDef));
                    for (var _i2 = 0, _Object$keys2 = Object.keys(inputProps); _i2 < _Object$keys2.length; _i2++) {
                        var key = _Object$keys2[_i2];
                        -1 === propNames.indexOf(key) && propNames.push(key);
                    }
                    var aliases = [];
                    var state = helpers.state, close = helpers.close, focus = helpers.focus, event = helpers.event, onError = helpers.onError;
                    for (var _i4 = 0; _i4 < propNames.length; _i4++) {
                        var _key = propNames[_i4];
                        var propDef = propsDef[_key];
                        var value = inputProps[_key];
                        if (propDef) {
                            var alias = propDef.alias;
                            if (alias) {
                                !Object(belter_src.isDefined)(value) && Object(belter_src.isDefined)(inputProps[alias]) && (value = inputProps[alias]);
                                aliases.push(alias);
                            }
                            propDef.value && (value = propDef.value({
                                props: props,
                                state: state,
                                close: close,
                                focus: focus,
                                event: event,
                                onError: onError
                            }));
                            !Object(belter_src.isDefined)(value) && propDef.default && (value = propDef.default({
                                props: props,
                                state: state,
                                close: close,
                                focus: focus,
                                event: event,
                                onError: onError
                            }));
                            if (Object(belter_src.isDefined)(value) && ("array" === propDef.type ? !Array.isArray(value) : typeof value !== propDef.type)) throw new TypeError("Prop is not of type " + propDef.type + ": " + _key);
                            props[_key] = value;
                        }
                    }
                    for (var _i6 = 0; _i6 < aliases.length; _i6++) delete props[aliases[_i6]];
                    for (var _i8 = 0, _Object$keys4 = Object.keys(props); _i8 < _Object$keys4.length; _i8++) {
                        var _key2 = _Object$keys4[_i8];
                        var _propDef = propsDef[_key2];
                        var _value = props[_key2];
                        _propDef && Object(belter_src.isDefined)(_value) && _propDef.decorate && (props[_key2] = _propDef.decorate({
                            value: _value,
                            props: props,
                            state: state,
                            close: close,
                            focus: focus,
                            event: event,
                            onError: onError
                        }));
                    }
                    for (var _i10 = 0, _Object$keys6 = Object.keys(propsDef); _i10 < _Object$keys6.length; _i10++) {
                        var _key3 = _Object$keys6[_i10];
                        var propVal = props[_key3];
                        if (!1 !== propsDef[_key3].required && !Object(belter_src.isDefined)(propVal)) throw new Error('Expected prop "' + _key3 + '" to be defined');
                    }
                }(propsDef, props, newProps, helpers, isUpdate);
            };
            var updateProps = function(newProps) {
                setProps(newProps, !0);
                return initPromise.then((function() {
                    var child = childComponent;
                    var proxyWin = currentProxyWin;
                    if (child && proxyWin) return getPropsForChild(getDomainMatcher()).then((function(childProps) {
                        return child.updateProps(childProps).catch((function(err) {
                            return checkWindowClose(proxyWin).then((function(closed) {
                                if (!closed) throw err;
                            }));
                        }));
                    }));
                }));
            };
            return {
                init: function() {
                    !function() {
                        event.on(constants.EVENT.RENDER, (function() {
                            return props.onRender();
                        }));
                        event.on(constants.EVENT.DISPLAY, (function() {
                            return props.onDisplay();
                        }));
                        event.on(constants.EVENT.RENDERED, (function() {
                            return props.onRendered();
                        }));
                        event.on(constants.EVENT.CLOSE, (function() {
                            return props.onClose();
                        }));
                        event.on(constants.EVENT.DESTROY, (function() {
                            return props.onDestroy();
                        }));
                        event.on(constants.EVENT.RESIZE, (function() {
                            return props.onResize();
                        }));
                        event.on(constants.EVENT.FOCUS, (function() {
                            return props.onFocus();
                        }));
                        event.on(constants.EVENT.PROPS, (function(newProps) {
                            return props.onProps(newProps);
                        }));
                        event.on(constants.EVENT.ERROR, (function(err) {
                            return props && props.onError ? props.onError(err) : initPromise.reject(err).then((function() {
                                setTimeout((function() {
                                    throw err;
                                }), 1);
                            }));
                        }));
                        clean.register(event.reset);
                    }();
                },
                render: function(target, container, context) {
                    return zalgo_promise_src.a.try((function() {
                        var uid = constants.ZOID + "-" + tag + "-" + Object(belter_src.uniqueID)();
                        var domain = getDomainMatcher();
                        var childDomain = getChildDomain();
                        !function(target, domain, container) {
                            if (target !== window) {
                                if (!Object(cross_domain_utils_src.t)(window, target)) throw new Error("Can only renderTo an adjacent frame");
                                var origin = Object(cross_domain_utils_src.h)();
                                if (!Object(cross_domain_utils_src.x)(domain, origin) && !Object(cross_domain_utils_src.s)(target)) throw new Error("Can not render remotely to " + domain.toString() + " - can only render to " + origin);
                                if (container && "string" != typeof container) throw new Error("Container passed to renderTo must be a string selector, got " + typeof container + " }");
                            }
                        }(target, domain, container);
                        var delegatePromise = zalgo_promise_src.a.try((function() {
                            if (target !== window) return function(context, target) {
                                var delegateProps = {};
                                for (var _i4 = 0, _Object$keys4 = Object.keys(props); _i4 < _Object$keys4.length; _i4++) {
                                    var propName = _Object$keys4[_i4];
                                    var propDef = propsDef[propName];
                                    propDef && propDef.allowDelegate && (delegateProps[propName] = props[propName]);
                                }
                                var childOverridesPromise = Object(src.h)(target, constants.POST_MESSAGE.DELEGATE + "_" + name, {
                                    overrides: {
                                        props: delegateProps,
                                        event: event,
                                        close: close,
                                        onError: onError,
                                        getInternalState: getInternalState,
                                        setInternalState: setInternalState
                                    }
                                }).then((function(_ref11) {
                                    var parent = _ref11.data.parent;
                                    clean.register((function() {
                                        if (!Object(cross_domain_utils_src.v)(target)) return parent.destroy();
                                    }));
                                    return parent.getDelegateOverrides();
                                })).catch((function(err) {
                                    throw new Error("Unable to delegate rendering. Possibly the component is not loaded in the target window.\n\n" + Object(belter_src.stringifyError)(err));
                                }));
                                getProxyContainerOverride = function() {
                                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                                    return childOverridesPromise.then((function(childOverrides) {
                                        return childOverrides.getProxyContainer.apply(childOverrides, args);
                                    }));
                                };
                                renderContainerOverride = function() {
                                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                                    return childOverridesPromise.then((function(childOverrides) {
                                        return childOverrides.renderContainer.apply(childOverrides, args);
                                    }));
                                };
                                showOverride = function() {
                                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                                    return childOverridesPromise.then((function(childOverrides) {
                                        return childOverrides.show.apply(childOverrides, args);
                                    }));
                                };
                                hideOverride = function() {
                                    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                                    return childOverridesPromise.then((function(childOverrides) {
                                        return childOverrides.hide.apply(childOverrides, args);
                                    }));
                                };
                                watchForUnloadOverride = function() {
                                    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
                                    return childOverridesPromise.then((function(childOverrides) {
                                        return childOverrides.watchForUnload.apply(childOverrides, args);
                                    }));
                                };
                                if (context === constants.CONTEXT.IFRAME) {
                                    getProxyWindowOverride = function() {
                                        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
                                        return childOverridesPromise.then((function(childOverrides) {
                                            return childOverrides.getProxyWindow.apply(childOverrides, args);
                                        }));
                                    };
                                    openFrameOverride = function() {
                                        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];
                                        return childOverridesPromise.then((function(childOverrides) {
                                            return childOverrides.openFrame.apply(childOverrides, args);
                                        }));
                                    };
                                    openPrerenderFrameOverride = function() {
                                        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) args[_key8] = arguments[_key8];
                                        return childOverridesPromise.then((function(childOverrides) {
                                            return childOverrides.openPrerenderFrame.apply(childOverrides, args);
                                        }));
                                    };
                                    prerenderOverride = function() {
                                        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) args[_key9] = arguments[_key9];
                                        return childOverridesPromise.then((function(childOverrides) {
                                            return childOverrides.prerender.apply(childOverrides, args);
                                        }));
                                    };
                                    openOverride = function() {
                                        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) args[_key10] = arguments[_key10];
                                        return childOverridesPromise.then((function(childOverrides) {
                                            return childOverrides.open.apply(childOverrides, args);
                                        }));
                                    };
                                    openPrerenderOverride = function() {
                                        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) args[_key11] = arguments[_key11];
                                        return childOverridesPromise.then((function(childOverrides) {
                                            return childOverrides.openPrerender.apply(childOverrides, args);
                                        }));
                                    };
                                } else context === constants.CONTEXT.POPUP && (setProxyWinOverride = function() {
                                    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) args[_key12] = arguments[_key12];
                                    return childOverridesPromise.then((function(childOverrides) {
                                        return childOverrides.setProxyWin.apply(childOverrides, args);
                                    }));
                                });
                                return childOverridesPromise;
                            }(context, target);
                        }));
                        var windowProp = props.window;
                        var watchForUnloadPromise = watchForUnload();
                        var buildUrlPromise = function(propsDef, props) {
                            var params = {};
                            var keys = Object.keys(props);
                            return zalgo_promise_src.a.all(keys.map((function(key) {
                                var prop = propsDef[key];
                                if (prop) return zalgo_promise_src.a.resolve().then((function() {
                                    var value = props[key];
                                    if (value && prop.queryParam) return value;
                                })).then((function(value) {
                                    if (null != value) return zalgo_promise_src.a.all([ getQueryParam(prop, key, value), getQueryValue(prop, 0, value) ]).then((function(_ref) {
                                        var queryParam = _ref[0], queryValue = _ref[1];
                                        var result;
                                        if ("boolean" == typeof queryValue) result = queryValue.toString(); else if ("string" == typeof queryValue) result = queryValue.toString(); else if ("object" == typeof queryValue && null !== queryValue) {
                                            if (prop.serialization === constants.PROP_SERIALIZATION.JSON) result = JSON.stringify(queryValue); else if (prop.serialization === constants.PROP_SERIALIZATION.BASE64) result = btoa(JSON.stringify(queryValue)); else if (prop.serialization === constants.PROP_SERIALIZATION.DOTIFY || !prop.serialization) {
                                                result = Object(belter_src.dotify)(queryValue, key);
                                                for (var _i12 = 0, _Object$keys8 = Object.keys(result); _i12 < _Object$keys8.length; _i12++) {
                                                    var dotkey = _Object$keys8[_i12];
                                                    params[dotkey] = result[dotkey];
                                                }
                                                return;
                                            }
                                        } else "number" == typeof queryValue && (result = queryValue.toString());
                                        params[queryParam] = result;
                                    }));
                                }));
                            }))).then((function() {
                                return params;
                            }));
                        }(propsDef, props).then((function(query) {
                            return Object(belter_src.extendUrl)(Object(cross_domain_utils_src.y)(getUrl()), {
                                query: query
                            });
                        }));
                        var onRenderPromise = event.trigger(constants.EVENT.RENDER);
                        var getProxyContainerPromise = getProxyContainer(container);
                        var getProxyWindowPromise = getProxyWindow();
                        var buildWindowNamePromise = getProxyWindowPromise.then((function(proxyWin) {
                            return function(_temp) {
                                var _ref4 = void 0 === _temp ? {} : _temp, proxyWin = _ref4.proxyWin, childDomain = _ref4.childDomain, domain = _ref4.domain, context = (void 0 === _ref4.target && window, 
                                _ref4.context), uid = _ref4.uid;
                                return function(proxyWin, childDomain, domain, uid) {
                                    return getPropsForChild(domain).then((function(childProps) {
                                        var value = Object(src.i)(proxyWin, domain, childProps);
                                        var propRef = childDomain === Object(cross_domain_utils_src.h)() ? {
                                            type: constants.INITIAL_PROPS.UID,
                                            uid: uid
                                        } : {
                                            type: constants.INITIAL_PROPS.RAW,
                                            value: value
                                        };
                                        if (propRef.type === constants.INITIAL_PROPS.UID) {
                                            var global = Object(lib.b)(window);
                                            global.props = global.props || {};
                                            global.props[uid] = value;
                                            clean.register((function() {
                                                delete global.props[uid];
                                            }));
                                        }
                                        return propRef;
                                    }));
                                }(proxyWin, childDomain, domain, uid).then((function(propsRef) {
                                    return {
                                        uid: uid,
                                        context: context,
                                        tag: tag,
                                        version: "9_0_63",
                                        childDomain: childDomain,
                                        parentDomain: Object(cross_domain_utils_src.h)(window),
                                        parent: getWindowRef(0, childDomain, uid, context),
                                        props: propsRef,
                                        exports: Object(src.i)(proxyWin, domain, (win = proxyWin, {
                                            init: initChild,
                                            close: close,
                                            checkClose: function() {
                                                return checkWindowClose(win);
                                            },
                                            resize: resize,
                                            onError: onError,
                                            show: show,
                                            hide: hide
                                        }))
                                    };
                                    var win;
                                }));
                            }({
                                proxyWin: (_ref5 = {
                                    proxyWin: proxyWin,
                                    childDomain: childDomain,
                                    domain: domain,
                                    target: target,
                                    context: context,
                                    uid: uid
                                }).proxyWin,
                                childDomain: _ref5.childDomain,
                                domain: _ref5.domain,
                                target: _ref5.target,
                                context: _ref5.context,
                                uid: _ref5.uid
                            }).then((function(childPayload) {
                                return "__" + constants.ZOID + "__" + name + "__" + Object(belter_src.base64encode)(JSON.stringify(childPayload)) + "__";
                            }));
                            var _ref5;
                        }));
                        var openFramePromise = buildWindowNamePromise.then((function(windowName) {
                            return openFrame(context, {
                                windowName: windowName
                            });
                        }));
                        var openPrerenderFramePromise = openPrerenderFrame(context);
                        var renderContainerPromise = zalgo_promise_src.a.hash({
                            proxyContainer: getProxyContainerPromise,
                            proxyFrame: openFramePromise,
                            proxyPrerenderFrame: openPrerenderFramePromise
                        }).then((function(_ref12) {
                            return renderContainer(_ref12.proxyContainer, {
                                context: context,
                                uid: uid,
                                proxyFrame: _ref12.proxyFrame,
                                proxyPrerenderFrame: _ref12.proxyPrerenderFrame
                            });
                        })).then((function(proxyContainer) {
                            return proxyContainer;
                        }));
                        var openPromise = zalgo_promise_src.a.hash({
                            windowName: buildWindowNamePromise,
                            proxyFrame: openFramePromise,
                            proxyWin: getProxyWindowPromise
                        }).then((function(_ref13) {
                            var proxyWin = _ref13.proxyWin;
                            return windowProp ? proxyWin : open(context, {
                                windowName: _ref13.windowName,
                                proxyWin: proxyWin,
                                proxyFrame: _ref13.proxyFrame
                            });
                        }));
                        var openPrerenderPromise = zalgo_promise_src.a.hash({
                            proxyWin: openPromise,
                            proxyPrerenderFrame: openPrerenderFramePromise
                        }).then((function(_ref14) {
                            return openPrerender(context, _ref14.proxyWin, _ref14.proxyPrerenderFrame);
                        }));
                        var setStatePromise = openPromise.then((function(proxyWin) {
                            currentProxyWin = proxyWin;
                            return setProxyWin(proxyWin);
                        }));
                        var prerenderPromise = zalgo_promise_src.a.hash({
                            proxyPrerenderWin: openPrerenderPromise,
                            state: setStatePromise
                        }).then((function(_ref15) {
                            return prerender(_ref15.proxyPrerenderWin, {
                                context: context,
                                uid: uid
                            });
                        }));
                        var setWindowNamePromise = zalgo_promise_src.a.hash({
                            proxyWin: openPromise,
                            windowName: buildWindowNamePromise
                        }).then((function(_ref16) {
                            if (windowProp) return _ref16.proxyWin.setName(_ref16.windowName);
                        }));
                        var loadUrlPromise = zalgo_promise_src.a.hash({
                            proxyWin: openPromise,
                            builtUrl: buildUrlPromise,
                            windowName: setWindowNamePromise,
                            prerender: prerenderPromise
                        }).then((function(_ref17) {
                            return _ref17.proxyWin.setLocation(_ref17.builtUrl);
                        }));
                        var watchForClosePromise = openPromise.then((function(proxyWin) {
                            !function watchForClose(proxyWin) {
                                var cancelled = !1;
                                clean.register((function() {
                                    cancelled = !0;
                                }));
                                return zalgo_promise_src.a.delay(2e3).then((function() {
                                    return proxyWin.isClosed();
                                })).then((function(isClosed) {
                                    return isClosed ? close() : cancelled ? void 0 : watchForClose(proxyWin);
                                }));
                            }(proxyWin);
                        }));
                        var onDisplayPromise = zalgo_promise_src.a.hash({
                            container: renderContainerPromise,
                            prerender: prerenderPromise
                        }).then((function() {
                            return event.trigger(constants.EVENT.DISPLAY);
                        }));
                        var openBridgePromise = openPromise.then((function(proxyWin) {
                            return function(proxyWin, domain, context) {
                                return zalgo_promise_src.a.try((function() {
                                    return proxyWin.awaitWindow();
                                })).then((function(win) {
                                    if (src.b && src.b.needsBridge({
                                        win: win,
                                        domain: domain
                                    }) && !src.b.hasBridge(domain, domain)) {
                                        var bridgeUrl = "function" == typeof options.bridgeUrl ? options.bridgeUrl({
                                            props: props
                                        }) : options.bridgeUrl;
                                        if (!bridgeUrl) throw new Error("Bridge needed to render " + context);
                                        var bridgeDomain = Object(cross_domain_utils_src.i)(bridgeUrl);
                                        src.b.linkUrl(win, domain);
                                        return src.b.openBridge(Object(cross_domain_utils_src.y)(bridgeUrl), bridgeDomain);
                                    }
                                }));
                            }(proxyWin, childDomain, context);
                        }));
                        var runTimeoutPromise = loadUrlPromise.then((function() {
                            return zalgo_promise_src.a.try((function() {
                                var timeout = props.timeout;
                                if (timeout) return initPromise.timeout(timeout, new Error("Loading component timed out after " + timeout + " milliseconds"));
                            }));
                        }));
                        var onRenderedPromise = initPromise.then((function() {
                            return event.trigger(constants.EVENT.RENDERED);
                        }));
                        return zalgo_promise_src.a.hash({
                            initPromise: initPromise,
                            buildUrlPromise: buildUrlPromise,
                            onRenderPromise: onRenderPromise,
                            getProxyContainerPromise: getProxyContainerPromise,
                            openFramePromise: openFramePromise,
                            openPrerenderFramePromise: openPrerenderFramePromise,
                            renderContainerPromise: renderContainerPromise,
                            openPromise: openPromise,
                            openPrerenderPromise: openPrerenderPromise,
                            setStatePromise: setStatePromise,
                            prerenderPromise: prerenderPromise,
                            loadUrlPromise: loadUrlPromise,
                            buildWindowNamePromise: buildWindowNamePromise,
                            setWindowNamePromise: setWindowNamePromise,
                            watchForClosePromise: watchForClosePromise,
                            onDisplayPromise: onDisplayPromise,
                            openBridgePromise: openBridgePromise,
                            runTimeoutPromise: runTimeoutPromise,
                            onRenderedPromise: onRenderedPromise,
                            delegatePromise: delegatePromise,
                            watchForUnloadPromise: watchForUnloadPromise
                        });
                    })).catch((function(err) {
                        return zalgo_promise_src.a.all([ onError(err), destroy(err) ]).then((function() {
                            throw err;
                        }), (function() {
                            throw err;
                        }));
                    })).then(belter_src.noop);
                },
                destroy: destroy,
                setProps: setProps,
                getHelpers: getHelpers,
                getDelegateOverrides: function() {
                    return zalgo_promise_src.a.try((function() {
                        return {
                            getProxyContainer: getProxyContainer,
                            show: show,
                            hide: hide,
                            renderContainer: renderContainer,
                            getProxyWindow: getProxyWindow,
                            watchForUnload: watchForUnload,
                            openFrame: openFrame,
                            openPrerenderFrame: openPrerenderFrame,
                            prerender: prerender,
                            open: open,
                            openPrerender: openPrerender,
                            setProxyWin: setProxyWin
                        };
                    }));
                }
            };
        }
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "component", (function() {
            return component_component;
        }));
        __webpack_require__.d(__webpack_exports__, "create", (function() {
            return create;
        }));
        __webpack_require__.d(__webpack_exports__, "destroyComponents", (function() {
            return destroyComponents;
        }));
        __webpack_require__.d(__webpack_exports__, "destroyAll", (function() {
            return destroyAll;
        }));
        __webpack_require__.d(__webpack_exports__, "destroy", (function() {
            return component_destroy;
        }));
        __webpack_require__.d(__webpack_exports__, "getBuiltInProps", (function() {
            return getBuiltInProps;
        }));
        var esm_extends = __webpack_require__(5);
        var src = __webpack_require__(4);
        var zalgo_promise_src = __webpack_require__(2);
        var cross_domain_utils_src = __webpack_require__(0);
        var belter_src = __webpack_require__(1);
        var lib = __webpack_require__(6);
        var constants = __webpack_require__(3);
        function normalizeChildProp(propsDef, props, key, value, helpers) {
            if (!propsDef.hasOwnProperty(key)) return value;
            var prop = propsDef[key];
            return "function" == typeof prop.childDecorate ? prop.childDecorate({
                value: value,
                uid: helpers.uid,
                close: helpers.close,
                focus: helpers.focus,
                onError: helpers.onError,
                onProps: helpers.onProps,
                resize: helpers.resize,
                getParent: helpers.getParent,
                getParentDomain: helpers.getParentDomain,
                show: helpers.show,
                hide: helpers.hide
            }) : value;
        }
        function parseChildWindowName(windowName) {
            return Object(belter_src.inlineMemoize)(parseChildWindowName, (function() {
                if (!windowName) throw new Error("No window name");
                var _windowName$split = windowName.split("__"), zoidcomp = _windowName$split[1], name = _windowName$split[2], encodedPayload = _windowName$split[3];
                if (zoidcomp !== constants.ZOID) throw new Error("Window not rendered by zoid - got " + zoidcomp);
                if (!name) throw new Error("Expected component name");
                if (!encodedPayload) throw new Error("Expected encoded payload");
                try {
                    return JSON.parse(Object(belter_src.base64decode)(encodedPayload));
                } catch (err) {
                    throw new Error("Can not decode window name payload: " + encodedPayload + ": " + Object(belter_src.stringifyError)(err));
                }
            }), [ windowName ]);
        }
        function getChildPayload() {
            try {
                return parseChildWindowName(window.name);
            } catch (err) {}
        }
        function child_focus() {
            return zalgo_promise_src.a.try((function() {
                window.focus();
            }));
        }
        function destroy() {
            return zalgo_promise_src.a.try((function() {
                window.close();
            }));
        }
        var parent_parent = __webpack_require__(9);
        __webpack_require__(8);
        function defaultContainerTemplate(_ref) {
            var uid = _ref.uid, frame = _ref.frame, prerenderFrame = _ref.prerenderFrame, doc = _ref.doc, props = _ref.props, event = _ref.event, _ref$dimensions = _ref.dimensions, width = _ref$dimensions.width, height = _ref$dimensions.height;
            if (frame && prerenderFrame) {
                var div = doc.createElement("div");
                div.setAttribute("id", uid);
                var style = doc.createElement("style");
                props.cspNonce && style.setAttribute("nonce", props.cspNonce);
                style.appendChild(doc.createTextNode("\n            #" + uid + " {\n                display: inline-block;\n                position: relative;\n                width: " + width + ";\n                height: " + height + ";\n            }\n\n            #" + uid + " > iframe {\n                display: inline-block;\n                position: absolute;\n                width: 100%;\n                height: 100%;\n                top: 0;\n                left: 0;\n                transition: opacity .2s ease-in-out;\n            }\n\n            #" + uid + " > iframe.zoid-invisible {\n                opacity: 0;\n            }\n\n            #" + uid + " > iframe.zoid-visible {\n                opacity: 1;\n        }\n        "));
                div.appendChild(frame);
                div.appendChild(prerenderFrame);
                div.appendChild(style);
                prerenderFrame.classList.add("zoid-visible");
                frame.classList.add("zoid-invisible");
                event.on(constants.EVENT.RENDERED, (function() {
                    prerenderFrame.classList.remove("zoid-visible");
                    prerenderFrame.classList.add("zoid-invisible");
                    frame.classList.remove("zoid-invisible");
                    frame.classList.add("zoid-visible");
                    setTimeout((function() {
                        Object(belter_src.destroyElement)(prerenderFrame);
                    }), 1);
                }));
                event.on(constants.EVENT.RESIZE, (function(_ref2) {
                    var newWidth = _ref2.width, newHeight = _ref2.height;
                    "number" == typeof newWidth && (div.style.width = Object(belter_src.toCSS)(newWidth));
                    "number" == typeof newHeight && (div.style.height = Object(belter_src.toCSS)(newHeight));
                }));
                return div;
            }
        }
        function defaultPrerenderTemplate(_ref) {
            var doc = _ref.doc, props = _ref.props;
            var html = doc.createElement("html");
            var body = doc.createElement("body");
            var style = doc.createElement("style");
            var spinner = doc.createElement("div");
            spinner.classList.add("spinner");
            props.cspNonce && style.setAttribute("nonce", props.cspNonce);
            html.appendChild(body);
            body.appendChild(spinner);
            body.appendChild(style);
            style.appendChild(doc.createTextNode("\n            html, body {\n                width: 100%;\n                height: 100%;\n            }\n\n            .spinner {\n                position: fixed;\n                max-height: 60vmin;\n                max-width: 60vmin;\n                height: 40px;\n                width: 40px;\n                top: 50%;\n                left: 50%;\n                box-sizing: border-box;\n                border: 3px solid rgba(0, 0, 0, .2);\n                border-top-color: rgba(33, 128, 192, 0.8);\n                border-radius: 100%;\n                animation: rotation .7s infinite linear;\n            }\n\n            @keyframes rotation {\n                from {\n                    transform: translateX(-50%) translateY(-50%) rotate(0deg);\n                }\n                to {\n                    transform: translateX(-50%) translateY(-50%) rotate(359deg);\n                }\n            }\n        "));
            return html;
        }
        var props_defaultNoop = function() {
            return belter_src.noop;
        };
        var props_decorateOnce = function(_ref) {
            var value = _ref.value;
            return Object(belter_src.once)(value);
        };
        function getBuiltInProps() {
            return {
                window: {
                    type: "object",
                    sendToChild: !1,
                    required: !1,
                    allowDelegate: !0,
                    validate: function(_ref2) {
                        var value = _ref2.value;
                        if (!Object(cross_domain_utils_src.u)(value) && !src.a.isProxyWindow(value)) throw new Error("Expected Window or ProxyWindow");
                        if (Object(cross_domain_utils_src.u)(value)) {
                            if (Object(cross_domain_utils_src.v)(value)) throw new Error("Window is closed");
                            if (!Object(cross_domain_utils_src.s)(value)) throw new Error("Window is not same domain");
                        }
                    },
                    decorate: function(_ref3) {
                        var value = _ref3.value;
                        return Object(src.k)(value);
                    }
                },
                timeout: {
                    type: "number",
                    required: !1,
                    sendToChild: !1
                },
                close: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref4) {
                        return _ref4.close;
                    }
                },
                focus: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref5) {
                        return _ref5.focus;
                    }
                },
                resize: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref6) {
                        return _ref6.resize;
                    }
                },
                uid: {
                    type: "string",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref7) {
                        return _ref7.uid;
                    }
                },
                cspNonce: {
                    type: "string",
                    required: !1
                },
                getParent: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref8) {
                        return _ref8.getParent;
                    }
                },
                getParentDomain: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref9) {
                        return _ref9.getParentDomain;
                    }
                },
                show: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref10) {
                        return _ref10.show;
                    }
                },
                hide: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref11) {
                        return _ref11.hide;
                    }
                },
                onDisplay: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    allowDelegate: !0,
                    default: props_defaultNoop,
                    decorate: props_decorateOnce
                },
                onRendered: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    default: props_defaultNoop,
                    decorate: props_decorateOnce
                },
                onRender: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    default: props_defaultNoop,
                    decorate: props_decorateOnce
                },
                onClose: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    allowDelegate: !0,
                    default: props_defaultNoop,
                    decorate: props_decorateOnce
                },
                onDestroy: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    allowDelegate: !0,
                    default: props_defaultNoop,
                    decorate: props_decorateOnce
                },
                onResize: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    allowDelegate: !0,
                    default: props_defaultNoop
                },
                onFocus: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    allowDelegate: !0,
                    default: props_defaultNoop
                },
                onError: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    childDecorate: function(_ref12) {
                        return _ref12.onError;
                    }
                },
                onProps: {
                    type: "function",
                    required: !1,
                    sendToChild: !1,
                    default: props_defaultNoop,
                    childDecorate: function(_ref13) {
                        return _ref13.onProps;
                    }
                }
            };
        }
        var cleanInstances = Object(belter_src.cleanup)();
        var cleanZoid = Object(belter_src.cleanup)();
        function component_component(opts) {
            var options = function(options) {
                var tag = options.tag, url = options.url, domain = options.domain, bridgeUrl = options.bridgeUrl, _options$props = options.props, propsDef = void 0 === _options$props ? {} : _options$props, _options$dimensions = options.dimensions, dimensions = void 0 === _options$dimensions ? {} : _options$dimensions, _options$autoResize = options.autoResize, autoResize = void 0 === _options$autoResize ? {} : _options$autoResize, _options$allowedParen = options.allowedParentDomains, allowedParentDomains = void 0 === _options$allowedParen ? constants.WILDCARD : _options$allowedParen, _options$attributes = options.attributes, attributes = void 0 === _options$attributes ? {} : _options$attributes, _options$defaultConte = options.defaultContext, defaultContext = void 0 === _options$defaultConte ? constants.CONTEXT.IFRAME : _options$defaultConte, _options$containerTem = options.containerTemplate, containerTemplate = void 0 === _options$containerTem ? defaultContainerTemplate : _options$containerTem, _options$prerenderTem = options.prerenderTemplate, prerenderTemplate = void 0 === _options$prerenderTem ? defaultPrerenderTemplate : _options$prerenderTem, validate = options.validate, _options$eligible = options.eligible, eligible = void 0 === _options$eligible ? function() {
                    return {
                        eligible: !0
                    };
                } : _options$eligible, _options$logger = options.logger, logger = void 0 === _options$logger ? {
                    info: belter_src.noop
                } : _options$logger;
                var name = tag.replace(/-/g, "_");
                var _dimensions$width = dimensions.width, width = void 0 === _dimensions$width ? constants.DEFAULT_DIMENSIONS.WIDTH : _dimensions$width, _dimensions$height = dimensions.height, height = void 0 === _dimensions$height ? constants.DEFAULT_DIMENSIONS.HEIGHT : _dimensions$height;
                propsDef = Object(esm_extends.a)({}, getBuiltInProps(), propsDef);
                if (!containerTemplate) throw new Error("Container template required");
                return {
                    name: name,
                    tag: tag,
                    url: url,
                    domain: domain,
                    bridgeUrl: bridgeUrl,
                    propsDef: propsDef,
                    dimensions: {
                        width: width,
                        height: height
                    },
                    autoResize: autoResize,
                    allowedParentDomains: allowedParentDomains,
                    attributes: attributes,
                    defaultContext: defaultContext,
                    containerTemplate: containerTemplate,
                    prerenderTemplate: prerenderTemplate,
                    validate: validate,
                    logger: logger,
                    eligible: eligible
                };
            }(opts);
            var name = options.name, tag = options.tag, defaultContext = options.defaultContext, eligible = options.eligible;
            var global = Object(lib.b)();
            var instances = [];
            var isChild = function() {
                var payload = getChildPayload();
                return Boolean(payload && payload.tag === tag && payload.childDomain === Object(cross_domain_utils_src.h)());
            };
            var registerChild = Object(belter_src.memoize)((function() {
                if (isChild()) {
                    if (window.xprops) {
                        delete global.components[tag];
                        throw new Error("Can not register " + name + " as child - child already registered");
                    }
                    var child = function(options) {
                        var propsDef = options.propsDef, autoResize = options.autoResize, allowedParentDomains = options.allowedParentDomains;
                        var onPropHandlers = [];
                        var childPayload = getChildPayload();
                        var props;
                        if (!childPayload) throw new Error("No child payload found");
                        if ("9_0_63" !== childPayload.version) throw new Error("Parent window has zoid version " + childPayload.version + ", child window has version 9_0_63");
                        var uid = childPayload.uid, parentDomain = childPayload.parentDomain, exports = childPayload.exports, context = childPayload.context, propsRef = childPayload.props;
                        var parentComponentWindow = function(ref) {
                            var type = ref.type;
                            if (type === constants.WINDOW_REFERENCES.OPENER) return Object(belter_src.assertExists)("opener", Object(cross_domain_utils_src.m)(window));
                            if (type === constants.WINDOW_REFERENCES.PARENT && "number" == typeof ref.distance) return Object(belter_src.assertExists)("parent", Object(cross_domain_utils_src.l)(window, ref.distance));
                            if (type === constants.WINDOW_REFERENCES.GLOBAL && ref.uid && "string" == typeof ref.uid) {
                                var uid = ref.uid;
                                var ancestor = Object(cross_domain_utils_src.f)(window);
                                if (!ancestor) throw new Error("Can not find ancestor window");
                                for (var _i2 = 0, _getAllFramesInWindow2 = Object(cross_domain_utils_src.e)(ancestor); _i2 < _getAllFramesInWindow2.length; _i2++) {
                                    var frame = _getAllFramesInWindow2[_i2];
                                    if (Object(cross_domain_utils_src.s)(frame)) {
                                        var global = Object(lib.b)(frame);
                                        if (global && global.windows && global.windows[uid]) return global.windows[uid];
                                    }
                                }
                            }
                            throw new Error("Unable to find " + type + " parent component window");
                        }(childPayload.parent);
                        var parent = Object(src.d)(parentComponentWindow, parentDomain, exports);
                        var show = parent.show, hide = parent.hide, close = parent.close;
                        var getParent = function() {
                            return parentComponentWindow;
                        };
                        var getParentDomain = function() {
                            return parentDomain;
                        };
                        var onProps = function(handler) {
                            onPropHandlers.push(handler);
                        };
                        var onError = function(err) {
                            return zalgo_promise_src.a.try((function() {
                                if (parent && parent.onError) return parent.onError(err);
                                throw err;
                            }));
                        };
                        var resize = function(_ref2) {
                            return parent.resize.fireAndForget({
                                width: _ref2.width,
                                height: _ref2.height
                            });
                        };
                        var setProps = function(newProps, origin, isUpdate) {
                            void 0 === isUpdate && (isUpdate = !1);
                            var normalizedProps = function(parentComponentWindow, propsDef, props, origin, helpers, isUpdate) {
                                void 0 === isUpdate && (isUpdate = !1);
                                var result = {};
                                for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {
                                    var key = _Object$keys2[_i2];
                                    var prop = propsDef[key];
                                    if (!prop || !prop.sameDomain || origin === Object(cross_domain_utils_src.h)(window) && Object(cross_domain_utils_src.s)(parentComponentWindow)) {
                                        var value = normalizeChildProp(propsDef, 0, key, props[key], helpers);
                                        result[key] = value;
                                        prop && prop.alias && !result[prop.alias] && (result[prop.alias] = value);
                                    }
                                }
                                if (!isUpdate) for (var _i4 = 0, _Object$keys4 = Object.keys(propsDef); _i4 < _Object$keys4.length; _i4++) {
                                    var _key = _Object$keys4[_i4];
                                    props.hasOwnProperty(_key) || (result[_key] = normalizeChildProp(propsDef, 0, _key, void 0, helpers));
                                }
                                return result;
                            }(parentComponentWindow, propsDef, newProps, origin, {
                                show: show,
                                hide: hide,
                                close: close,
                                focus: child_focus,
                                onError: onError,
                                resize: resize,
                                onProps: onProps,
                                getParent: getParent,
                                getParentDomain: getParentDomain,
                                uid: uid
                            }, isUpdate);
                            props ? Object(belter_src.extend)(props, normalizedProps) : props = normalizedProps;
                            for (var _i4 = 0; _i4 < onPropHandlers.length; _i4++) (0, onPropHandlers[_i4])(props);
                        };
                        var updateProps = function(newProps) {
                            return zalgo_promise_src.a.try((function() {
                                return setProps(newProps, parentDomain, !0);
                            }));
                        };
                        return {
                            init: function() {
                                return zalgo_promise_src.a.try((function() {
                                    !function(allowedParentDomains, domain) {
                                        if (!Object(cross_domain_utils_src.x)(allowedParentDomains, domain)) throw new Error("Can not be rendered by domain: " + domain);
                                    }(allowedParentDomains, parentDomain);
                                    Object(src.f)(parentComponentWindow);
                                    !function() {
                                        window.addEventListener("beforeunload", (function() {
                                            parent.checkClose.fireAndForget();
                                        }));
                                        window.addEventListener("unload", (function() {
                                            parent.checkClose.fireAndForget();
                                        }));
                                        Object(cross_domain_utils_src.z)(parentComponentWindow, (function() {
                                            destroy();
                                        }));
                                    }();
                                    return parent.init({
                                        updateProps: updateProps,
                                        close: destroy
                                    });
                                })).then((function() {
                                    return (_autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, 
                                    _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, 
                                    _autoResize$element = autoResize.element, elementRef = void 0 === _autoResize$element ? "body" : _autoResize$element, 
                                    Object(belter_src.elementReady)(elementRef).catch(belter_src.noop).then((function(element) {
                                        return {
                                            width: width,
                                            height: height,
                                            element: element
                                        };
                                    }))).then((function(_ref3) {
                                        var width = _ref3.width, height = _ref3.height, element = _ref3.element;
                                        element && (width || height) && context !== constants.CONTEXT.POPUP && Object(belter_src.onResize)(element, (function(_ref4) {
                                            resize({
                                                width: width ? _ref4.width : void 0,
                                                height: height ? _ref4.height : void 0
                                            });
                                        }), {
                                            width: width,
                                            height: height
                                        });
                                    }));
                                    var _autoResize$width, width, _autoResize$height, height, _autoResize$element, elementRef;
                                })).catch((function(err) {
                                    onError(err);
                                }));
                            },
                            getProps: function() {
                                if (props) return props;
                                setProps(function(parentComponentWindow, domain, _ref) {
                                    var type = _ref.type, uid = _ref.uid;
                                    var props;
                                    if (type === constants.INITIAL_PROPS.RAW) props = _ref.value; else if (type === constants.INITIAL_PROPS.UID) {
                                        if (!Object(cross_domain_utils_src.s)(parentComponentWindow)) throw new Error("Parent component window is on a different domain - expected " + Object(cross_domain_utils_src.h)() + " - can not retrieve props");
                                        var global = Object(lib.b)(parentComponentWindow);
                                        props = Object(belter_src.assertExists)("props", global && global.props[uid]);
                                    }
                                    if (!props) throw new Error("Could not find props");
                                    return Object(src.d)(parentComponentWindow, domain, props);
                                }(parentComponentWindow, parentDomain, propsRef), parentDomain);
                                return props;
                            }
                        };
                    }(options);
                    child.init();
                    return child;
                }
            }));
            registerChild();
            !function() {
                var allowDelegateListener = Object(src.g)(constants.POST_MESSAGE.ALLOW_DELEGATE + "_" + name, (function() {
                    return !0;
                }));
                var delegateListener = Object(src.g)(constants.POST_MESSAGE.DELEGATE + "_" + name, (function(_ref) {
                    var source = _ref.source, overrides = _ref.data.overrides;
                    return {
                        parent: Object(parent_parent.a)(options, overrides, source)
                    };
                }));
                cleanZoid.register(allowDelegateListener.cancel);
                cleanZoid.register(delegateListener.cancel);
            }();
            global.components = global.components || {};
            if (global.components[tag]) throw new Error("Can not register multiple components with the same tag: " + tag);
            global.components[tag] = !0;
            return {
                init: function init(props) {
                    var instance;
                    var _eligible = eligible({
                        props: props = props || {}
                    }), eligibility = _eligible.eligible, reason = _eligible.reason;
                    var onDestroy = props.onDestroy;
                    props.onDestroy = function() {
                        instance && eligibility && instances.splice(instances.indexOf(instance), 1);
                        if (onDestroy) return onDestroy.apply(void 0, arguments);
                    };
                    var parent = Object(parent_parent.a)(options);
                    parent.init();
                    eligibility ? parent.setProps(props) : props.onDestroy && props.onDestroy();
                    cleanInstances.register((function() {
                        parent.destroy(new Error("zoid destroyed all components"));
                    }));
                    var _render = function(target, container, context) {
                        return zalgo_promise_src.a.try((function() {
                            if (!eligibility) return parent.destroy().then((function() {
                                throw new Error(reason || name + " component is not eligible");
                            }));
                            if (!Object(cross_domain_utils_src.u)(target)) throw new Error("Must pass window to renderTo");
                            return function(props, context) {
                                return zalgo_promise_src.a.try((function() {
                                    if (props.window) return Object(src.k)(props.window).getType();
                                    if (context) {
                                        if (context !== constants.CONTEXT.IFRAME && context !== constants.CONTEXT.POPUP) throw new Error("Unrecognized context: " + context);
                                        return context;
                                    }
                                    return defaultContext;
                                }));
                            }(props, context);
                        })).then((function(finalContext) {
                            container = function(context, container) {
                                if (container) {
                                    if ("string" != typeof container && !Object(belter_src.isElement)(container)) throw new TypeError("Expected string or element selector to be passed");
                                    return container;
                                }
                                if (context === constants.CONTEXT.POPUP) return "body";
                                throw new Error("Expected element to be passed to render iframe");
                            }(finalContext, container);
                            return parent.render(target, container, finalContext);
                        })).catch((function(err) {
                            return parent.destroy(err).then((function() {
                                throw err;
                            }));
                        }));
                    };
                    instance = Object(esm_extends.a)({}, parent.getHelpers(), {
                        isEligible: function() {
                            return eligibility;
                        },
                        clone: function(_temp) {
                            var _ref3$decorate = (void 0 === _temp ? {} : _temp).decorate;
                            return init((void 0 === _ref3$decorate ? belter_src.identity : _ref3$decorate)(props));
                        },
                        render: function(container, context) {
                            return _render(window, container, context);
                        },
                        renderTo: function(target, container, context) {
                            return _render(target, container, context);
                        }
                    });
                    eligibility && instances.push(instance);
                    return instance;
                },
                instances: instances,
                driver: function(driverName, dep) {
                    throw new Error("Driver support not enabled");
                },
                isChild: isChild,
                canRenderTo: function(win) {
                    return Object(src.h)(win, constants.POST_MESSAGE.ALLOW_DELEGATE + "_" + name).then((function(_ref2) {
                        return _ref2.data;
                    })).catch((function() {
                        return !1;
                    }));
                },
                registerChild: registerChild
            };
        }
        function create(options) {
            Object(src.j)();
            var comp = component_component(options);
            var init = function(props) {
                return comp.init(props);
            };
            init.driver = function(name, dep) {
                return comp.driver(name, dep);
            };
            init.isChild = function() {
                return comp.isChild();
            };
            init.canRenderTo = function(win) {
                return comp.canRenderTo(win);
            };
            init.instances = comp.instances;
            var child = comp.registerChild();
            child && (window.xprops = init.xprops = child.getProps());
            return init;
        }
        function destroyComponents() {
            src.b && src.b.destroyBridges();
            var destroyPromise = cleanInstances.all();
            cleanInstances = Object(belter_src.cleanup)();
            return destroyPromise;
        }
        var destroyAll = destroyComponents;
        function component_destroy() {
            destroyAll();
            Object(lib.a)();
            cleanZoid.all();
            Object(src.e)();
        }
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "PopupOpenError", (function() {
            return PopupOpenError;
        }));
        __webpack_require__.d(__webpack_exports__, "create", (function() {
            return create;
        }));
        __webpack_require__.d(__webpack_exports__, "destroy", (function() {
            return destroy;
        }));
        __webpack_require__.d(__webpack_exports__, "destroyComponents", (function() {
            return destroyComponents;
        }));
        __webpack_require__.d(__webpack_exports__, "destroyAll", (function() {
            return destroyAll;
        }));
        __webpack_require__.d(__webpack_exports__, "PROP_TYPE", (function() {
            return PROP_TYPE;
        }));
        __webpack_require__.d(__webpack_exports__, "PROP_SERIALIZATION", (function() {
            return PROP_SERIALIZATION;
        }));
        __webpack_require__.d(__webpack_exports__, "CONTEXT", (function() {
            return CONTEXT;
        }));
        __webpack_require__.d(__webpack_exports__, "EVENT", (function() {
            return EVENT;
        }));
        var isServer = "undefined" == typeof window;
        var PopupOpenError = (isServer ? {} : __webpack_require__(1)).PopupOpenError;
        isServer || __webpack_require__(10);
        isServer || __webpack_require__(12);
        var _ref4 = isServer ? {} : __webpack_require__(10), create = _ref4.create, destroy = _ref4.destroy, destroyComponents = _ref4.destroyComponents, destroyAll = _ref4.destroyAll;
        var _ref5 = isServer ? {} : __webpack_require__(3), PROP_TYPE = _ref5.PROP_TYPE, PROP_SERIALIZATION = _ref5.PROP_SERIALIZATION, CONTEXT = _ref5.CONTEXT, EVENT = _ref5.EVENT;
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var _parent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
        __webpack_require__.d(__webpack_exports__, "parentComponent", (function() {
            return _parent__WEBPACK_IMPORTED_MODULE_0__.a;
        }));
    } ]);
}));